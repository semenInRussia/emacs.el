#+TITLE: Config of Emacs from semenInRussia
#+AUTHOR: semenInRussia

* Hi!
  Hello, This is configuration of Emacs from semenInRussia!

  My moto is "Good Luck!", so my homepage is "Good Luck":

  #+BEGIN_SRC emacs-lisp :tangle ~/init.el

    (setq initial-buffer-choice "~/Start.org")

  #+END_SRC

  I'm use followed repositories as a template for my Emacs config:

  - [[https://github.com/jkitchin/scimax/][jkitchin/scimax]] (org mode, and auto format functions)
  - [[https://github.com/magnars/.emacs.d][magnars/.emacs.d]] (smart insertion, a lot of snippets, and other)

* Table of Contents                                                    :TOC:
- [[#hi][Hi!]]
- [[#package-management---base][Package Management - base]]
  - [[#use-package][use-package]]
  - [[#packages-not-in-melpaelpaorg-elpa][Packages Not in MELPA/ELPA/ORG-ELPA]]
    - [[#stranger-packages][Stranger Packages]]
    - [[#my-packages][My Packages]]
- [[#writing-this-config][Writing This Config]]
  - [[#libraries][Libraries]]
    - [[#s][s]]
    - [[#f][f]]
    - [[#dash][Dash]]
  - [[#my-small-standard-library][My Small Standard Library]]
    - [[#work-with-files][Work with Files]]
    - [[#work-with-strings][Work with Strings]]
    - [[#work-with-lists][Work with Lists]]
  - [[#function-for-work-with-the-emacs][Function for work with the Emacs]]
  - [[#auto-tangle-this-file][Auto Tangle This File]]
- [[#info-about-me-for-emacs][Info about Me for Emacs]]
  - [[#congurlation-me-with-my-birthday][Congurlation me with my Birthday!]]
- [[#organize-editing][Organize Editing]]
  - [[#snippets][Snippets]]
    - [[#some-snippets][Some Snippets]]
    - [[#ignore-case-in-snippets-expansion][Ignore Case in Snippets' Expansion]]
  - [[#linters][Linters]]
  - [[#autocomplete][Autocomplete]]
    - [[#more-pretty-auto-complete][More Pretty Auto Complete]]
  - [[#format-all-code][Format All Code]]
    - [[#i-am-russian][I am Russian!]]
  - [[#main-keymaps][Main keymaps]]
    - [[#easy-create-major-modes-maps][Easy Create Major Modes Maps]]
      - [[#setup-for-major-mode-map][Setup for =:major-mode-map=]]
      - [[#normalizer-for-major-mode-map][Normalizer for =:major-mode-map=]]
      - [[#major-mode-maps-handler][=major-mode-map='s Handler]]
  - [[#fast-executing-command][Fast Executing Command]]
  - [[#functions-for-define-keys][Functions for Define Keys]]
  - [[#search][Search]]
    - [[#search-in-file][Search in File]]
    - [[#search-in-very-some-file][Search in Very Some File]]
  - [[#search-and-replace][Search and Replace]]
    - [[#search-and-replace-in-project][Search and Replace in Project]]
    - [[#search-and-replace-in-current-buffer][Search and Replace in Current Buffer]]
  - [[#change-case-of-text][Change Case of Text]]
  - [[#auto-indent-aggressive][Auto indent (aggressive)]]
  - [[#navigation-beetween-functionsclassesetc][Navigation beetween Functions/Classes/etc.]]
    - [[#in-project][In Project]]
  - [[#smart-commentuncomment][Smart Comment/Uncomment]]
  - [[#jump-to-defnition][Jump to Defnition]]
  - [[#multiple-cursors][Multiple Cursors]]
  - [[#very-fast-jump][Very Fast Jump]]
  - [[#smart-parens][Smart Parens]]
    - [[#smartparens][Smartparens]]
    - [[#special-configuration-for-major-modes][Special Configuration for Major Modes]]
    - [[#delete-only-parens-without-inner-contents][Delete Only Parens without Inner Contents]]
  - [[#smart-select-text][Smart Select Text]]
  - [[#macros][Macros]]
  - [[#special-strings-as-seperated-buffers][Special Strings as Seperated Buffers]]
  - [[#transpose][Transpose]]
    - [[#define-extensible-drag-system][Define Extensible Drag System]]
    - [[#draggers-of-drag-stuff][Draggers of =drag-stuff=]]
    - [[#draggers-for-org-mode][Draggers for =org-mode=]]
  - [[#custom-deleting-text][Custom Deleting Text]]
  - [[#custom-selecting-text][Custom Selecting Text]]
  - [[#custom-editing-text][Custom Editing Text]]
  - [[#custom-navigation][Custom Navigation]]
  - [[#rectangles][Rectangles]]
  - [[#indent-settings][Indent Settings]]
- [[#support-of-languages][Support of Languages]]
  - [[#functions-for-extending-functional-of-language][Functions for extending functional of language]]
    - [[#functions-for-navigation][Functions for Navigation]]
    - [[#functions-for-pretty-view][Functions for Pretty View]]
    - [[#functions-for-import][Functions for Import]]
    - [[#functions-for-auto-format-code][Functions for Auto Format Code]]
  - [[#supported-languages][Supported Languages]]
    - [[#latex][LaTeX]]
      - [[#latex--calc][LaTeX + calc]]
      - [[#preview-latex][Preview Latex]]
      - [[#fast-navigation-and-insertion-in-latex][Fast Navigation and Insertion in LaTeX]]
      - [[#insert-pairs-in-latex][Insert Pairs in LaTeX]]
      - [[#latex-tables][LaTeX Tables]]
      - [[#variables-for-latex][Variables for LaTeX]]
      - [[#visual-fill-for-latex][Visual Fill for LaTeX]]
      - [[#keymaps-for-latex][Keymaps for LaTeX]]
      - [[#auto-complete-for-latex][Auto Complete for LaTeX]]
      - [[#auto-activating-snippets-for-latex][Auto Activating Snippets for LaTeX]]
      - [[#auto-format-in-latex][Auto Format in LaTeX]]
      - [[#equation-environment-to-split-environment][Equation Environment to Split Environment]]
      - [[#insert-any-image-at-url-in-latex][Insert any image at URL in LaTeX]]
    - [[#org][Org]]
      - [[#centering-org][Centering Org]]
      - [[#auto-format-in-org][Auto Format in Org]]
      - [[#load-from-wiki][Load from Wiki]]
      - [[#drag-and-drop-images-to-org][Drag and Drop Images to Org]]
      - [[#navigation-beetween-org-headings-in-current-buffer][Navigation beetween Org Headings in Current Buffer]]
      - [[#improvement-navigation-beetween-org-headings][Improvement Navigation beetween Org Headings]]
      - [[#paste-link-from-browser][Paste Link from Browser]]
      - [[#generate-table-of-contents-in-org][Generate Table of Contents in Org]]
      - [[#org--cdlatex][Org + CDLaTeX]]
    - [[#elisp][Elisp]]
      - [[#special-linters][Special Linters]]
      - [[#refactoring][Refactoring]]
      - [[#package-manager][Package Manager]]
      - [[#elisp-format-code][Elisp Format Code]]
      - [[#modern-documentation][Modern Documentation]]
      - [[#elisp-docstrings-mode][Elisp Docstrings Mode]]
      - [[#elisp-indent-code][Elisp Indent Code]]
      - [[#some-insertion-functions-for-elisp][Some Insertion Functions for Elisp]]
    - [[#markdown][Markdown]]
      - [[#create-table-of-contents-in-markdown][Create Table of Contents in Markdown]]
      - [[#auto-format-in-markdown][Auto Format in markdown]]
    - [[#python][Python]]
      - [[#vars][Vars]]
      - [[#navigation][Navigation]]
      - [[#linters-1][Linters]]
      - [[#helping-info][Helping info]]
      - [[#autocomplete-1][Autocomplete]]
    - [[#rust][Rust]]
      - [[#auto-completion-in-rust][Auto Completion in Rust]]
      - [[#check-errors][Check Errors]]
    - [[#go-lang][Go Lang]]
      - [[#add-import][Add Import]]
    - [[#pdf][PDF]]
    - [[#haskell][Haskell]]
      - [[#auto-completion-for-haskell][Auto Completion for Haskell]]
    - [[#javascript-nodejs][JavaScript (Node.js)]]
      - [[#variables][Variables]]
      - [[#repl][Repl]]
      - [[#linters-2][Linters]]
      - [[#navigation-1][Navigation]]
    - [[#json][JSON]]
    - [[#html][HTML]]
      - [[#variables-1][Variables]]
      - [[#web-mode][Web Mode]]
      - [[#auto-rename-tag][Auto Rename Tag]]
      - [[#emmet][Emmet]]
      - [[#paredit-for-html][=Paredit= for HTML]]
      - [[#auto-complete-for-html][Auto Complete for HTML]]
    - [[#css][CSS]]
      - [[#fly-documentation][Fly Documentation]]
- [[#support-of-some-special-modes][Support of Some Special Modes]]
  - [[#calc][Calc]]
- [[#small-organize-tricks][Small Organize Tricks]]
  - [[#very-small-tricks][Very Small Tricks]]
  - [[#highlight-git-changes][Highlight Git Changes]]
  - [[#helpful][Helpful]]
    - [[#which-key][Which Key?]]
    - [[#helpful-package][Helpful Package]]
  - [[#autocompletion-of-commands-helm][Autocompletion of Commands (HELM)]]
  - [[#command-log][Command Log]]
  - [[#whitespaces-mode][Whitespaces Mode]]
  - [[#visual-fill-line-mode][Visual Fill Line Mode]]
  - [[#auto-fill-paragraphs][Auto Fill Paragraphs]]
  - [[#scratches][Scratches]]
  - [[#syntax-subword-mode][Syntax Subword Mode]]
  - [[#small-pandoc-functions][Small Pandoc Functions]]
  - [[#i-am-russian-1][I am Russian!]]
  - [[#disable-or-enable-modes][Disable or Enable Modes]]
  - [[#cow-say][Cow Say]]
  - [[#auto-save][Auto Save]]
  - [[#read-documentation-for-developers][Read Documentation for Developers]]
  - [[#pomidor][Pomidor]]
  - [[#pacman][Pacman]]
  - [[#wikipedia][Wikipedia]]
  - [[#view-github-stars][View Github Stars]]
  - [[#easy-generate-gitignore][Easy Generate .gitignore]]
  - [[#google][Google]]
  - [[#kinopoisk][Kinopoisk]]
  - [[#make-broken-pptx-file][Make Broken PPTX File]]
  - [[#films-management][Films Management]]
  - [[#see-recent-files][See Recent Files]]
  - [[#take-color-or-face][Take Color or Face]]
- [[#graphic-user-interface][Graphic User Interface]]
  - [[#hide-all][Hide ALL]]
  - [[#color-themes][Color Themes]]
    - [[#gruber-darker-theme][Gruber Darker Theme]]
    - [[#some-proffesional-themes][Some Proffesional Themes]]
    - [[#some-other-themes][Some other themes]]
    - [[#load-theme][Load Theme]]
  - [[#numbers-of-lines][Numbers of lines]]
    - [[#vars-1][Vars]]
    - [[#enable-and-disable][Enable and Disable]]
  - [[#modeline][Modeline]]
    - [[#modeline-for-drag][Modeline for =drag=]]
    - [[#disable-view-of-xah-fly-keys-state][Disable View of =xah-fly-keys= State]]
    - [[#watch-time-in-doom-modeline][Watch Time in Doom-Modeline]]
    - [[#pomidor-in-modeline][Pomidor in Modeline]]
    - [[#truncate-buffers-name-in-modeline][Truncate Buffer's Name in Modeline]]
    - [[#no-display-flycheck-in-modeline][No Display =flycheck= in Modeline]]
    - [[#enable-modeline][Enable Modeline]]
  - [[#fonts][Fonts]]
  - [[#highlight-current-line][Highlight Current Line]]
  - [[#centering][Centering]]
  - [[#view-break-page-lines][View Break Page Lines]]
- [[#developer-environment][Developer Environment]]
  - [[#projects-management][Projects Management]]
    - [[#projectile-with-helm][Projectile with Helm]]
  - [[#regexp-ide][Regexp IDE]]
  - [[#git][Git]]
    - [[#fly-view-authors-of-changes][Fly View Authors of Changes]]
    - [[#undo-with-git][Undo with Git]]
    - [[#git-major-modes][Git Major Modes]]
    - [[#genreate-gitignore][Genreate .gitignore]]
  - [[#view-directories][View Directories]]
  - [[#just-run-current-file][Just Run Current File]]
  - [[#run-command][Run Command]]
    - [[#run-command-recipes][Run Command Recipes]]
  - [[#projects-with-templates][Projects with Templates]]
  - [[#snitch][Snitch]]
    - [[#highlight-todos][Highlight TODOs]]
    - [[#run-snitch-commands][Run Snitch Commands]]
  - [[#organization][Organization]]
  - [[#notes][Notes]]
- [[#mipt][MIPT]]
  - [[#management-of-mipt-files][Management of MIPT Files]]
  - [[#copy-content-of-file-as-mipt-solution][Copy Content of File as MIPT Solution]]

* Package Management - base
** use-package
   I am use [[https://github.com/jwiegley/use-package][use-package]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el
     (require 'package)

     (setq package-archives
           '(("melpa-stable" . "http://stable.melpa.org/packages/")
             ("melpa"        . "https://melpa.org/packages/")
             ("org"          . "https://orgmode.org/elpa/")
             ("elpa"         . "https://elpa.gnu.org/packages/")))

     (package-initialize)
     (unless package-archive-contents
       (package-refresh-contents))

     (unless (package-installed-p 'use-package)
       (package-install 'use-package))

     (require 'use-package)
  #+END_SRC
** Packages Not in MELPA/ELPA/ORG-ELPA
*** Stranger Packages

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (add-to-list 'load-path "~/.emacs.d/lisp")

    #+END_SRC

*** My Packages

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (add-to-list 'load-path "~/projects/fast-exec.el")
      (add-to-list 'load-path "~/projects/porth-mode")
      (add-to-list 'load-path "~/projects/emacs-run-command")
      (add-to-list 'load-path "~/projects/simple-indention.el")

    #+END_SRC

* Writing This Config
  I am use some packages for simple develop on Emacs Lisp
** Libraries
*** s
    This is [[https://github.com/magnars/s.el][s]]:
    #+BEGIN_SRC emacs-lisp :tangle ~/init.el
      (use-package s :ensure t)
      #+END_SRC

*** f
    This is [[https://github.com/rejeep/f.el][f]]:

    #+BEGIN_SRC emacs-lisp  :tangle  ~/init.el
      (use-package f :ensure t)
      #+END_SRC

*** Dash
    This is [[https://github.com/magnars/dash.el][dash:]]
    #+BEGIN_SRC emacs-lisp  :tangle  ~/init.el

      (use-package dash :ensure t :init (global-dash-fontify-mode 1))

      #+END_SRC
** My Small Standard Library
*** Work with Files
    Function =my-try-delete= delete file when it is exists, otherwise
    do nothing:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (defun my-try-delete (path &optional force)
        "If PATH is exists isn't exists, then just do nothing, otherwise delete PATH.

      If FORCE is t, a directory will be deleted recursively."
        (when (f-exists-p path)
          (f-delete path force)))

   #+END_SRC

   Function =my-try-move= also if file is exists, then move one to
   other or do nothing:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defun my-try-move (from to)
       "Move FROM to TO, if FROM is exists."
       (when (f-exists-p from)
         (f-move from to)))

   #+END_SRC

   Function =my-files-with-extension= return list of files in
   directory which has extension:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defun my-files-with-extension (ext dir)
       "Return list of files in DIR which has extension EXT."
       (->>
        dir
        (f-files)
        (--filter (f-ext-p it ext))))

   #+END_SRC
*** Work with Strings
    Functions =my-humanize-string= and =my-normalize-string= transform
    strings as =print-something-real-noral= to "Print Something Real
    Noral" and to back.

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (defun my-humanize-string (s)
        "Humanize normalized S."
        (->> s (s-replace "-" " ") (s-titleize)))

      (defun my-normalize-string (s)
        "Normalize humanized S for computer."
        (->>
         s
         (s-downcase)
         (s-replace " " "-")
         (s-replace "'" "")
         (s-replace "\"" "")))

    #+END_SRC

    Function =my-one-of-prefixes-p= return t, when taked string has
    one of taked prefixes:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (defun my-one-of-prefixes-p (prefixes s)
        "Return t, when S has one of PREFIXES."
        (->>
         prefixes
         (--some (s-prefix-p it s))))
    #+END_SRC

    Function =my-parts-of-string= take =number= and =string=, and
    return list of strings with same length:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (defun my-parts-of-string (n s)
        "Divide string S to N same parts.'"
        (->>
         (my-parts-of-seq n s)
         (--map (apply #'s-concat it))))

    #+END_SRC

*** Work with Lists
    =dash= has function =-max= which return maximal value from of
    passed list, but this functions raise error when list is empty, so
    I writed function =my-max=:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (defun my-max (list)
        "Return the max value of LIST, if LIST is empty, then return nil."
        (when list
          (-max list)))

    #+END_SRC

    Function =my-into-list= take any object and transform it to list:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el
      (defun my-into-list (obj)
        "Transform OBJ to list.
      Supoorted types of OBJ:
      - `string'
      - `list'"
        (cl-typecase obj
          (list obj)
          (string (my-string-to-list obj))))

      (defun my-string-to-list (s)
        "Transform S to list of 1 size string."
        (->>
         s
         (string-to-list)
         (-map #'char-to-string)))

    #+END_SRC

    Function =my-parts-of-seq= take any object and number of wanted
    lists with type which has support of =my-into-list= and divide
    list to N lists with same length:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (defun my-parts-of-seq (n seq)
        "Divide SEQ to N same parts.
      SEQ may be one of types which supported in function `my-into-list'"
        (setq seq (my-into-list seq))
        (let ((step (/ (length seq) n)))
          (-partition-in-steps step step seq)))


    #+END_SRC
** Function for work with the Emacs
   I created library =just= which has a lot of power functions for
   work with Emacs

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package just
         :load-path "~/projects/just/just.el")

   #+END_SRC


** Auto Tangle This File

   #+BEGIN_SRC emacs-lisp  :tangle  ~/init.el

     (defun if-Emacs-org-then-org-babel-tangle ()
       "If current open file is Emacs.org, then `org-babel-tangle`."
       (interactive)

       (when (s-equals? (f-filename buffer-file-name) "Emacs.org")
         (org-babel-tangle)))

     (add-hook 'after-save-hook 'if-Emacs-org-then-org-babel-tangle)

     #+END_Src

* Info about Me for Emacs

  #+BEGIN_SRC emacs-lisp :tangle ~/init.el

    (setq user-full-name    "Semen Khramtsov"
          user-mail-address "hrams205@gmail.com"
          user-birthday     "2007-01-29"
          user-name         "semenInRussia"
          user-os           "Windows" ; "Windows" or "Linux"
          )

    (defun user-os-windows-p ()
      "If user have os Windows, then return t.
    Info take from var `user-os`, user must set it."
      (interactive)
      (s-equals? user-os "Windows"))

      #+END_SRC

** Congurlation me with my Birthday!

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (if (s-equals? (format-time-string "%Y-%m-%d") user-birthday)
         (animate-birthday-present))

         #+END_SRC

* Organize Editing
** Snippets
   I am use [[https://github.com/joaotavora/yasnippet][yasnippet]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el
     (use-package yasnippet
         :ensure t
         :init
         (yas-global-mode 1)
         :custom
         (yas-snippet-dirs '("~/.emacs.d/snippets"))
         (yas-wrap-around-region t))

    #+END_SRC

*** Some Snippets
    I am use [[https://github.com/AndreaCrotti/yasnippet-snippets][yasnippet-snippets]].  This is default collection of
    snippets for [[https://github.com/joaotavora/yasnippet][yasnippet]]:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package yasnippet-snippets
          :ensure t)

    #+END_SRC

*** Ignore Case in Snippets' Expansion
    When I am use =org= first symbol of the sentence will
    automatically capitalizated, so when I insert /equ/ this will
    changed to /Equ/, and when I am press =TAB=, instead of expanding
    snippet (use =yas-expand=), the cursor moved to next position (use
    =cdlatex-tab=), so I must change this Sheet:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el


      (defun yas--fetch (table key)
        "Fetch templates in TABLE by KEY.

      Return a list of cons (NAME . TEMPLATE) where NAME is a
      string and TEMPLATE is a `yas--template' structure."
        (let* ((key (s-downcase key))
               (keyhash (yas--table-hash table))
               (namehash (and keyhash (gethash key keyhash))))
          (when namehash
            (yas--filter-templates-by-condition
             (yas--namehash-templates-alist namehash)))))

    #+END_SRC

** Linters
   I am use [[https://www.flycheck.org/en/latest/][flycheck]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package flycheck
         :ensure t
         :config
         '(custom-set-variables
           '(flycheck-display-errors-function
             #'flycheck-pos-tip-error-messages))
         (global-flycheck-mode 1))

         #+END_SRC

** Autocomplete
   I am use [[http://company-mode.github.io][company-mode]], I am set delay beetween typing text and viewing hints to
   0.8 seconds:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package company
         :ensure t
         :custom
         (company-idle-delay                 0.3)
         (company-minimum-prefix-length      2)
         (company-show-numbers               t)
         (company-tooltip-limit              15)
         (company-tooltip-align-annotations  t)
         (company-tooltip-flip-when-above    t)
         (company-dabbrev-ignore-case        nil)
         :config
         (add-to-list 'company-backends 'company-keywords)
         (global-company-mode 1))

         #+END_SRC

   And for =yasnippet= I am use code from [[https://emacs.stackexchange.com/questions/10431/get-company-to-show-suggestions-for-yasnippet-names][this]] stackexchange:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defvar company-mode/enable-yas t
       "Enable yasnippet for all backends.")

     (defun company-mode/backend-with-yas (backend)
       (if (or (not company-mode/enable-yas)
               (and (listp backend) (member 'company-yasnippet backend)))
           backend
         (append (if (consp backend) backend (list backend))
                 '(:with company-yasnippet))))

     (setq company-backends
           (mapcar #'company-mode/backend-with-yas company-backends))

           #+END_SRC

*** More Pretty Auto Complete
    I am use popular [[https://github.com/sebastiencs/company-box][company-box]]:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package company-box
          :ensure t
          :hook (company-mode . company-box-mode))

          #+END_SRC

** Format All Code
   Each programmer need to format code for this I am use [[https://github.com/lassik/emacs-format-all-the-code][format-all]],
   its support 65 languages:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package format-all
         :ensure t)

         #+END_SRC

*** I am Russian!
    I am need to use russian letters as english in key hots:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el
    #+END_SRC

** Main keymaps
   I am use [[https://github.com/xahlee/xah-fly-keys][xah-fly-keys]], this as VIM, but keymaps created for keyboard (in VIM keymaps created for easy remember):

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package xah-fly-keys
         :config
       (xah-fly-keys-set-layout "qwerty")
       (xah-fly-keys 1)
       (define-key xah-fly-command-map (kbd "SPC l") nil)
       (define-key xah-fly-command-map (kbd "SPC j") nil)
       (define-key xah-fly-command-map (kbd "SPC SPC") nil))

       #+END_SRC
*** Easy Create Major Modes Maps
    I am use =use-package=, so I'm add flag =:major-mode-map= for create major modes in =use-package= macro, I am bind local major mode map to =SPC l=:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (defvar my-local-major-mode-map nil
        "My map for current `major-mode'")

      (defun my-local-major-mode-map-run ()
        "Run `my-local-major-mode-map'."
        (interactive)
        (set-transient-map my-local-major-mode-map))

      (define-key xah-fly-command-map (kbd "SPC l") 'my-local-major-mode-map-run)

      #+END_SRC

**** Setup for =:major-mode-map=

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (add-to-list 'use-package-keywords :major-mode-map)

       #+END_SRC

**** Normalizer for =:major-mode-map=
     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (defun use-package-normalize/:major-mode-map (name keyword args)
         "Normalizer of :major-mode-map for `use-package'."
         (let* (map-name modes)
           (if (eq (-first-item args) t)
               (list (symbol-name name) (list name))
             (cl-typecase (-first-item args)
               (null nil)
               (list (setq modes (-first-item args)))
               (symbol (setq map-name (symbol-name (-first-item args))))
               (string (setq map-name (-first-item args))))
             (cl-typecase (-second-item args)
               (null nil)
               (list (setq modes (-second-item args)))
               (symbol (setq map-name (symbol-name (-second-item args))))
               (string (setq map-name (-second-item args))))
             (list
              (or map-name (symbol-name name))
              modes))))

    #+END_SRC

**** =major-mode-map='s Handler
     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (defun use-package-handler/:major-mode-map (name keyword
                                                   map-name-and-modes rest state)
         (let* ((map-name (car map-name-and-modes))
                (modes (-second-item map-name-and-modes))
                (modes-hooks (--map (intern (s-append "-hook" (symbol-name it)))
                                    modes))
                (map (intern (s-concat "my-" map-name "-local-map"))))
           (setq rest
                 (-concat
                  rest
                  `(:config
                    ((unless (boundp ',map)
                       (define-prefix-command ',map))
                     (--each ',modes-hooks
                       (add-hook it
                                 (lambda ()
                                   (setq-local my-local-major-mode-map
                                               ',map))))))))
           (use-package-process-keywords name rest)))

           #+END_SRC

** Fast Executing Command
   I am use [[https://github.com/semenInRussia/fast-exec.el][fast-exec]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (require 'fast-exec)

     (fast-exec/enable-some-builtin-supports haskell-mode
                                             flycheck
                                             magit
                                             org-agenda
                                             deadgrep
                                             projectile
                                             package
                                             skeletor
                                             yasnippet
                                             format-all
                                             wikinforg
                                             suggest
                                             devdocs
                                             helm-wikipedia)

     (fast-exec/initialize)

     (define-key xah-fly-command-map (kbd "=") 'fast-exec/exec)

     #+END_SRC

** Functions for Define Keys

   Function =define-key-when= is wrap on =define-key=, but function DEF will call when
   will pressed KEY in KEYMAP and when CONDITION will true:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defmacro define-key-when (fun-name map key def pred)
       "Define to KEY in MAP DEF when PRED return t or run old command.
     Instead of KEY will command FUN-NAME"
       (let ((old-def (key-binding key)))
         `(unless (eq (key-binding ,key) #',fun-name)
            (defun ,fun-name ()
              ,(s-lex-format "Run `${old-def}' or `${def}'.")
              (interactive)
              (call-interactively
               (if (funcall ,pred)
                   ,def
                 #',old-def)))
            (define-key ,map ,key #',fun-name))))

              #+END_SRC

** Search
*** Search in File

    I am press ='= for search anything in current buffer.  I am use
    [[https://github.com/emacsorphanage/helm-swoop][helm-swoop]], this is interactive way to search any string in
    buffer.  I'm press =M-j= and I will be can edit all selected
    things, after I can press (=SPC ;=) for apply all edits.  Also I
    can press =SPC k '= for search anything in all buffers with same
    major mode.

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package helm-swoop
          :ensure t
          :bind ((:map xah-fly-command-map)
                 ("'" . 'helm-swoop)
                 ("SPC k '" . 'helm-multi-swoop-current-mode)
                 (:map helm-swoop-map)
                 ("M-j" . 'helm-swoop-edit)
                 (:map helm-swoop-edit-map)
                 ([remap save-buffer] . 'helm-swoop--edit-complete)))

    #+END_SRC

*** Search in Very Some File
    I am use [[https://github.com/Wilfred/deadgrep][deadgrep]], because I am love =Rust=:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package deadgrep
          :ensure t
          :bind (:map
                 xah-fly-command-map
                 ("SPC '" . deadgrep)))

                 #+END_SRC

** Search and Replace
   I am use =SPC r= for replace word in buffer, and =SPC SPC r= for replace word in project:

*** Search and Replace in Project

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (define-key xah-fly-command-map (kbd "SPC SPC r") 'projectile-replace)

    #+END_SRC

*** Search and Replace in Current Buffer
    I am use [[https://github.com/benma/visual-regexp.el][visual-regexp]].  This is like replace-regexp, but with
    live visual feedback directly in the buffer.

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package visual-regexp
          :ensure t
          :bind ((:map xah-fly-command-map)
                 ("SPC r" . 'vr/query-replace)))

    #+END_SRC

** Change Case of Text
   I am use [[https://github.com/akicho8/string-inflection][string-inflection]] for change case of text on cycle

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package string-inflection
         :ensure t
         :bind ((:map xah-fly-command-map)
                ("b" . 'string-inflection-cycle)))

   #+END_SRC

** Auto indent (aggressive)
   I am use [[https://github.com/Malabarba/aggressive-indent-mode/][aggressive-indent-mode]].  When I'm press space, all will
   indented (see [[https://github.com/Malabarba/aggressive-indent-mode/][docs]])

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el


     (use-package aggressive-indent
         :ensure t
         :hook ((emacs-lisp-mode css-mode) . aggressive-indent-mode))

   #+END_SRC

** Navigation beetween Functions/Classes/etc.
   I am use =imenu= with =Helm= and keymap =SPC SPC SPC=:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el
     (use-package imenu
         :custom (imenu-auto-rescan t))

     (bind-keys :map xah-fly-command-map
                ("SPC SPC SPC" . helm-imenu))

                #+END_SRC

*** In Project
    For Imenu In Project I am use [[https://github.com/vspinu/imenu-anywhere][imenu-anywhere]]:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package imenu-anywhere
          :ensure t
          :bind (:map xah-fly-command-map
                      ("SPC SPC n" . imenu-anywhere)))

                      #+END_SRC

** Smart Comment/Uncomment
   I am use [[https://github.com/remyferre/comment-dwim-2][comment-dwim-2]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package comment-dwim-2
         :ensure t
         :bind (:map xah-fly-command-map
                     ("z" . comment-dwim-2)))

                     #+END_SRC

** Jump to Defnition
   I am use [[https://github.com/jacktasia/dumb-jump][cool package dumb-jump]] for jump to defnition in 50+ languages:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package rg
         :ensure t)

     (use-package dumb-jump
         :ensure t
         :custom
         (dumb-jump-force-searcher 'rg)
         (dumb-jump-prefer-searcher 'rg)
         :bind (:map xah-fly-command-map ("SPC SPC ." . dumb-jump-back))
         :init
         (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))

         #+END_SRC

** Multiple Cursors
   I am use package of magnars [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]:

   #+BEGIN_SRC emacs-lisp  :tangle  ~/init.el

     (defun my-buffer-list-or-edit-lines ()
       "Do `helm-buffer-list' or `mc/edit-lines'."
       (interactive)
       (if (use-region-p)
           (call-interactively #'mc/edit-lines)
         (call-interactively #'helm-multi-files)))

     (defun my-mark-all ()
       "If enable `multiple-cursors', then mark all like this, other mark buffer."
       (interactive)
       (if multiple-cursors-mode
           (mc/mark-all-words-like-this)
         (mark-whole-buffer)))

     (defun my-bob-or-mc-align ()
       "If enable `multiple-cursors', then mark then align by regexp, other bob.
     BOB - is `beginning-of-buffer'"
       (interactive)
       (if multiple-cursors-mode
           (call-interactively 'mc/vertical-align)
         (beginning-of-buffer)))

     (defun my-eob-or-mc-align-with-space ()
       "If enable `multiple-cursors', then align by spaces, other bob.
     EOB - is `end-of-buffer'"
       (interactive)
       (if multiple-cursors-mode
           (mc/vertical-align-with-space)
         (end-of-buffer)))

     (defun my-mc-mark-like-this-or-edit-lines ()
       "If region on some lines, `mc/edit-lines' other `mc/mark-next-like-this'."
       (interactive)
       (if (and (region-active-p)
                (not (eq (line-number-at-pos (region-beginning))
                         (line-number-at-pos (region-end)))))
           (call-interactively 'mc/edit-lines)
         (call-interactively 'mc/mark-next-like-this-word)))

     (use-package multiple-cursors :ensure t)

     (use-package multiple-cursors
         :config
       (add-to-list 'mc--default-cmds-to-run-once 'my-mark-all)
       (add-to-list 'mc--default-cmds-to-run-once
                    'my-mc-mark-like-this-or-edit-lines)
       (add-to-list 'mc--default-cmds-to-run-once
                    'my-bob-or-mc-align)
       (add-to-list 'mc--default-cmds-to-run-once
                    'my-eob-or-align-with-spaces)
       (add-to-list 'mc--default-cmds-to-run-once
                    'my-mc-mark-like-this-or-edit-lines)
       (add-to-list 'mc--default-cmds-to-run-once
                    'toggle-input-method)
       :bind
       (:map xah-fly-command-map
             ("SPC f"         . 'my-buffer-list-or-edit-lines)
             ("7"         . my-mc-mark-like-this-or-edit-lines)
             ("SPC 7"     . mc/mark-previous-like-this-word)
             ("SPC TAB 7" . mc/reverse-regions)
             ("SPC d 7"   . mc/unmark-next-like-this)
             ("SPC h"     . my-bob-or-mc-align)
             ("SPC n"     . my-eob-or-mc-align-with-space)
             ("SPC a"     . my-mark-all)))

             #+END_SRC

** Very Fast Jump
   I am use [[https://github.com/abo-abo/avy][avy]]:

   #+BEGIN_SRC emacs-lisp  :tangle  ~/init.el

     (use-package avy
         :ensure t
         :custom (avy-background t)
         (avy-translate-char-function #'translate-char-from-russian)
         :bind ((:map xah-fly-command-map)
                ("n"     . nil) ; by default this is `isearch', so i turn
                ;; this to keymap
                ("n n"   . 'avy-goto-char)
                ("n v"   . 'avy-yank-word)
                ("n x"   . 'avy-teleport-word)
                ("n c"   . 'avy-copy-word)
                ("n 8"   . 'avy-mark-word)
                ("n d"   . 'avy-kill-word-stay)
                ("n s ;" . 'avy-insert-new-line-at-eol)
                ("n s h" . 'avy-insert-new-line-at-bol)
                ("n 5"   . 'avy-zap)
                ("n TAB" . 'avy-transpose-words)
                ("n w"   . 'avy-clear-line)
                ("n -"   . 'avy-sp-splice-sexp-in-word)
                ("n r"   . 'avy-kill-word-move)
                ("n o"   . 'avy-change-word)
                ("n 9"   . 'avy-sp-change-enclosing-in-word)
                ("n z"   . 'avy-comment-line)
                ("n t v" . 'avy-copy-region)
                ("n t d" . 'avy-kill-region)
                ("n t x" . 'avy-move-region)
                ("n t c" . 'avy-kill-ring-save-region)
                ("n ;"   . 'avy-goto-end-of-line)
                ("n h"   . 'avy-goto-begin-of-line-text)
                ("n k v" . 'avy-copy-line)
                ("n k x" . 'avy-move-line)
                ("n k c" . 'avy-kill-ring-save-whole-line)
                ("n k d" . 'avy-kill-whole-line)))

     (defun translate-char-from-russian (russian-char)
       "Translate RUSSIAN-CHAR to corresponding char on qwerty keyboard.
     I am use йцукенг russian keyboard."
       (cl-case russian-char
         (?й ?q)
         (?ц ?w)
         (?у ?e)
         (?к ?r)
         (?е ?t)
         (?н ?y)
         (?г ?u)
         (?ш ?i)
         (?щ ?o)
         (?з ?p)
         (?ф ?a)
         (?ы ?s)
         (?в ?d)
         (?а ?f)
         (?п ?g)
         (?р ?h)
         (?о ?j)
         (?л ?k)
         (?д ?l)
         (?я ?z)
         (?ч ?x)
         (?с ?c)
         (?м ?v)
         (?и ?b)
         (?т ?n)
         (?ь ?m)
         (t russian-char)))

     (defun avy-goto-word-1-with-action (char action &optional arg beg end symbol)
       "Jump to the currently visible CHAR at a word start.
     The window scope is determined by `avy-all-windows'.
     When ARG is non-nil, do the opposite of `avy-all-windows'.
     BEG and END narrow the scope where candidates are searched.
     When SYMBOL is non-nil, jump to symbol start instead of word start.
     Do action of `avy' ACTION.'"
       (interactive (list (read-char "char: " t) current-prefix-arg))
       (avy-with avy-goto-word-1
         (let* ((str (string char))
                (regex
                 (cond
                   ((string= str ".")
                    "\\.")
                   ((and avy-word-punc-regexp
                         (string-match avy-word-punc-regexp str))
                    (regexp-quote str))
                   ((<= char 26)
                    str)
                   (t (concat (if symbol "\\_<" "\\b") str)))))
           (avy-jump regex
                     :window-flip arg
                     :beg beg
                     :end end
                     :action action))))

     (defun avy-zap (char &optional arg)
       "Zapping to next CHAR navigated by `avy'."
       (interactive "cchar:\nP")
       (avy-jump
        (s-concat (char-to-string char))
        :window-flip arg
        :beg (point-min)
        :end (point-max)
        :action 'avy-action-zap-to-char))

     (defun avy-teleport-word (char &optional arg)
       "Teleport word searched by `arg' with CHAR.
     Pass ARG to `avy-jump'."
       (interactive "cchar:\nP")
       (avy-goto-word-1-with-action char 'avy-action-teleport))

     (defun avy-mark-word (char)
       "Mark word begining with CHAR searched by `avy'."
       (interactive "cchar: ")
       (avy-goto-word-1-with-action char 'avy-action-mark))

     (defun avy-copy-word (char &optional arg)
       "Copy word searched by `arg' with CHAR.
     Pass ARG to `avy-jump'."
       (interactive "cchar:\nP")
       (avy-goto-word-1-with-action char 'avy-action-copy))

     (defun avy-yank-word (char &optional arg)
       "Paste word searched by `arg' with CHAR.
     Pass ARG to `avy-jump'."
       (interactive "cchar:\nP")
       (avy-goto-word-1-with-action char 'avy-action-yank))

     (defun avy-kill-word-stay (char &optional arg)
       "Paste word searched by `arg' with CHAR.
     Pass ARG to `avy-jump'."
       (interactive "cchar:\nP")
       (avy-goto-word-1-with-action char 'avy-action-kill-stay))

     (defun avy-kill-word-move (char &optional arg)
       "Paste word searched by `arg' with CHAR.
     Pass ARG to `avy-jump'."
       (interactive "cchar:\nP")
       (avy-goto-word-1-with-action char 'avy-action-kill-move))

     (defun avy-goto-line-1-with-action (action)
       "Goto line via `avy' with CHAR and do ACTION."
       (interactive)
       (avy-jump "^." :action action))

     (defun avy-comment-line ()
       "With `avy' move to line and comment its."
       (interactive)
       (avy-goto-line-1-with-action 'avy-action-comment))

     (defun avy-action-comment (pt)
       "Saving excursion comment line at point PT."
       (save-excursion (goto-char pt) (comment-line 1)))

     (defun avy-sp-change-enclosing-in-word (ch)
       "With `avy' move to word starting with CH and `sp-change-enclosing'."
       (interactive "cchar:")
       (avy-goto-word-1-with-action ch 'avy-action-sp-change-enclosing))

     (defun avy-action-sp-change-enclosing (pt)
       "Saving excursion `sp-change-enclosing' in word at point PT."
       (save-excursion (goto-char pt) (sp-change-enclosing)))

     (defun avy-sp-splice-sexp-in-word (ch)
       "With `avy' move to word starting with CH and `sp-splice-sexp'."
       (interactive "cchar:")
       (avy-goto-word-1-with-action ch 'avy-action-sp-splice-sexp))

     (defun avy-action-sp-splice-sexp (pt)
       "Saving excursion `sp-splice-sexp' in word at point PT."
       (save-excursion (goto-char pt) (sp-splice-sexp)))

     (defun avy-change-word (ch)
       "With `avy' move to word starting with CH and change its any other."
       (interactive "cchar:")
       (avy-goto-word-1-with-action ch 'avy-action-change-word))

     (defun avy-action-change-word (pt)
       "Saving excursion navigate to word at point PT and change its."
       (save-excursion
         (avy-action-kill-move pt)
         (insert (read-string "new word, please: " (current-kill 0)))))

     (defun avy-transpose-words (char)
       "Goto CHAR via `avy' and transpose at point word to word at prev point."
       (interactive "cchar: ")
       (avy-goto-word-1-with-action char 'avy-action-transpose-words))

     (defun avy-action-transpose-words (second-pt)
       "Goto SECOND-PT via `avy' and transpose at point to word at point ago."
       (avy-action-yank second-pt)
       (kill-sexp)
       (goto-char second-pt)
       (yank)
       (kill-sexp))

     (defun avy-goto-begin-of-line-text (&optional arg)
       "Call `avy-goto-line' and move to the begin of the text of line.
     ARG is will be passed to `avy-goto-line'"
       (interactive "p")
       (avy-goto-line arg)
       (beginning-of-line-text))

     (defun avy-clear-line (&optional arg)
       "Move to any line via `avy' and clear this line from begin to end.
     ARG is will be passed to `avy-goto-line'"
       (interactive "p")
       (avy-goto-line-1-with-action #'avy-action-clear-line))

     (defun avy-action-clear-line (pt)
       "Move to PT, and clear current line, move back.
     Action of `avy', see `avy-action-yank' for example"
       (save-excursion (goto-char pt) (clear-current-line)))

     (defun avy-insert-new-line-at-eol ()
       "Move to any line via `avy' and insert new line at end of line."
       (interactive)
       (avy-goto-line-1-with-action #'avy-action-insert-new-line-at-eol))

     (defun avy-action-insert-new-line-at-eol (pt)
       "Move to PT, and insert new line at end of line, move back.
     Action of `avy', see `avy-action-yank' for example"
       (save-excursion
         (goto-char pt)
         (end-of-line)
         (newline)))

     (defun avy-insert-new-line-at-bol ()
       "Move to any line via `avy' and insert new at beginning of line."
       (interactive)
       (avy-goto-line-1-with-action #'avy-action-insert-new-line-at-bol))

     (defun avy-action-insert-new-line-at-bol (pt)
       "Move to PT, and insert new at beginning of line, move back.
     Action of `avy', see `avy-action-yank' for example"
       (save-excursion
         (goto-char pt)
         (beginning-of-line)
         (newline)))
       #+END_SRC

** Smart Parens
*** Smartparens
    I am use [[https://github.com/Fuco1/smartparens/][smartparens]], for slurp expresion I am use =]=, also for
    splice parens I am use =-= , for navigating I am use =.= and =m=:

    #+BEGIN_SRC emacs-lisp  :tangle  ~/init.el

      (use-package smartparens
          :ensure t
          :init
          (smartparens-global-mode 1)
          :bind (("RET"       . sp-newline)
                  ("M-("       . 'sp-wrap-round)
                  ("M-{"       . 'sp-wrap-curly)
                 :map
                 xah-fly-command-map
                 (("]"         . 'sp-forward-slurp-sexp)
                  ("["         . 'sp-forward-barf-sexp)
                  ("M-("       . 'sp-wrap-round)
                  ("M-["       . 'sp-wrap-square)
                  ("M-{"       . 'sp-wrap-curly)
                  ("-"         . 'sp-splice-sexp)
                  ("SPC -"     . 'sp-rewrap-sexp)
                  ("m"         . 'sp-backward-sexp)
                  ("."         . 'sp-forward-sexp)
                  ("SPC 1"     . 'sp-join-sexp)
                  ("SPC SPC 1" . 'sp-split-sexp)
                  ("SPC 9"     . 'sp-change-enclosing)
                  ("SPC SPC g" . 'sp-kill-hybrid-sexp)
                  ("SPC ="     . 'sp-raise-sexp))))

                  #+END_SRC
*** Special Configuration for Major Modes
    For enable builtin smartparens configuration for major modes, add require statement to =.emacs.el=, with name of major mode and smartparens prefix:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (require 'smartparens-config)

      #+END_SRC

*** Delete Only Parens without Inner Contents

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el
      (defun delete-only-1-char ()
        "Delete only 1 character before point."
        (interactive)
        (backward-char)
        (delete-char 1)
        )

      (define-key xah-fly-command-map (kbd "DEL") 'delete-only-1-char)
      #+END_SRC

** Smart Select Text
   I am use cool package [[https://github.com/magnars/expand-region.el/][expand-region]]:
   #+BEGIN_SRC emacs-lisp  :tangle  ~/init.el
     (defun mark-inner-or-expand-region ()
       "If text is selected, expand region, otherwise then mark inner of brackets."
       (interactive)
       (if (use-region-p)
           (call-interactively 'er/expand-region)
         (progn
           (-when-let (ok (sp-get-sexp))
             (sp-get ok
               (set-mark :beg-in)
               (goto-char :end-in))))))

     (use-package expand-region
         :ensure t
         :bind
         (:map xah-fly-command-map
               ("1" . er/expand-region)
               ("9" . mark-inner-or-expand-region)
               ("m" . sp-backward-up-sexp)))

               #+END_SRC
** Macros
   I am use =\= in command mode for start of record macro.
   I am also use =SPC RET= for execute last macro or execute macro to lines:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el
     (defun kmacro-start-or-end-macro ()
       "If macro record have just started, then stop this record, otherwise start."
       (interactive)
       (if defining-kbd-macro
           (kmacro-end-macro 1)
         (kmacro-start-macro 1)))

     (define-key xah-fly-command-map (kbd "\\") 'kmacro-start-or-end-macro)

     (defun kmacro-call-macro-or-apply-to-lines (arg &optional top bottom)
       "If selected region, then apply macro to selected lines, otherwise call macro."
       (interactive
        (list
         1
         (if (use-region-p) (region-beginning) nil)
         (if (use-region-p) (region-end) nil)))

       (if (use-region-p)
           (apply-macro-to-region-lines top bottom)
         (kmacro-call-macro arg)))

     (define-key xah-fly-command-map (kbd "SPC RET") 'kmacro-call-macro-or-apply-to-lines)

     #+END_SRC

   #+RESULTS:
   : kmacro-call-macro-or-apply-to-lines
** Special Strings as Seperated Buffers
   I am use [[https://github.com/magnars/string-edit.el][string-edit]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package string-edit
         :ensure t
         :bind (:map xah-fly-command-map
                     ("SPC `" . string-edit-at-point)))

                     #+END_SRC

** Transpose
   For example I am press =SPC TAB o=, then current word will moved to
   right, but again press this hard key sequence is hard, so I am
   press just =o=, and current word again moved to right, next time I
   am press =i= and now line moved to up.

*** Define Extensible Drag System
    I want to agile system of drag, because in each cases my drag
    functions must can do each things.  For agile I have
    followed functions:

  - =add-left-dragger=
  - =add-down-dragger=
  - =add-up-dragger=
  - =add-right-dragger=

    This functions take =dragger= which take zero arguments, and
    return t when word was successufully moved:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el
      (defun my-drag-stuff-left-char ()
        "Drag char to left."
        (interactive)
        (transpose-chars -1))

      (defun my-drag-stuff-right-char ()
        "Drag char to right."
        (interactive)
        (transpose-chars 1))

      (defcustom my-left-draggers nil
        "Functions, which drag stuff to left, or return nil.
      Is used in `my-drag-stuff-left'.")

      (defun my-drag-stuff-left ()
        "My more general and functional version of `drag-stuff-left'."
        (interactive)
        (--find (call-interactively it) my-left-draggers)
        (message "Start dragging, use keys u, i, o, k. Type RET for exit..."))

      (defcustom my-right-draggers nil
        "Functions, which drag stuff to right, or return nil.
      Is used in `my-drag-stuff-right'.")

      (defun my-drag-stuff-right ()
        "My more general and functional version of `drag-stuff-right'."
        (interactive)
        (--find (call-interactively it) my-right-draggers)
        (message "Start dragging, use keys u, i, o, k. Type RET for exit..."))

      (defcustom my-up-draggers nil
        "Functions, which drag stuff to up, or return nil.
      Is used in `my-drag-stuff-up'.")

      (defun my-drag-stuff-up ()
        "My more general and functional version of `drag-stuff-up'."
        (interactive)
        (--find (call-interactively it) my-up-draggers)
        (message "Start dragging, use keys u, i, o, k. Type RET for exit..."))

      (defcustom my-down-draggers nil
        "Functions, which drag stuff to up, or return nil.
      Is used in `my-drag-stuff-down'.")

      (defun my-drag-stuff-down ()
        "My more general and functional version of `drag-stuff-down'."
        (interactive)
        (--find (call-interactively it) my-down-draggers)
        (message "Start dragging, use keys u, i, o, k. Type RET for exit..."))

      (defun add-left-dragger (f)
        "Add F to list draggers for `my-drag-stuff-left'."
        (when (-contains-p my-left-draggers f)
          (setq my-left-draggers (remove f my-left-draggers)))
        (setq my-left-draggers (cons f my-left-draggers)))

      (defun add-right-dragger (f)
        "Add F to list draggers for `my-drag-stuff-right'."
        (when (-contains-p my-right-draggers f)
          (setq my-right-draggers (remove f my-right-draggers)))
        (setq my-right-draggers (cons f my-right-draggers)))

      (defun add-up-dragger (f)
        "Add F to list draggers for `my-drag-stuff-up'."
        (when (-contains-p my-up-draggers f)
          (setq my-up-draggers (remove f my-up-draggers)))
        (setq my-up-draggers (cons f my-up-draggers)))

      (defun add-down-dragger (f)
        "Add F to list draggers for `my-drag-stuff-down'."
        (when (-contains-p my-down-draggers f)
          (setq my-down-draggers (remove f my-down-draggers)))
        (setq my-down-draggers (cons f my-down-draggers)))

      (defun add-right-dragger (f)
        "Add F to list draggers for `my-drag-stuff-right'."
        (when (-contains-p my-right-draggers f)
          (setq my-right-draggers (remove f my-right-draggers)))
        (setq my-right-draggers (cons f my-right-draggers)))

      (defcustom my-drag-stuff-functions '(my-drag-stuff-up
                                           my-drag-stuff-down
                                           my-drag-stuff-right
                                           my-drag-stuff-left
                                           my-drag-stuff-right-char
                                           my-drag-stuff-left-char)
        "List of my functions, which always drag stuffs.")

      (defun my-last-command-is-drag-stuff-p ()
        "Get t, when last command is one of `my-drag-stuff-functions'."
        (interactive)
        (-contains-p my-drag-stuff-functions last-command))

      (defvar my-last-command-is-drag-stuff nil
        "If last command is one of my functions which draged word then this in true.")

      (defun my-last-command-is-dragged-stuff-p ()
        "Return t, when last command dragged someone stuff."
        (or
         (my-last-command-is-drag-stuff-p)
         (and
          (s-contains-p "drag-stuff" (symbol-name last-command))
          my-last-command-is-drag-stuff)))

      (defmacro my-define-stuff-key (keymap key normal-command drag-command)
        "Define in KEYMAP to KEY command when run NORMAL-COMMAND or DRAG-COMMAND."
        (let ((command-name (intern
                             (s-concat
                              "my-"
                              (symbol-name (eval normal-command))
                              "-or-"
                              (symbol-name (eval drag-command))))))
          `(progn
             (defun ,command-name ()
               ,(s-lex-format "Run `${normal-command}' or `${drag-command}'.")
               (interactive)
               (let* ((is-drag (my-last-command-is-dragged-stuff-p)))
                 (setq my-last-command-is-drag-stuff is-drag)
                 (if is-drag
                     (call-interactively ,drag-command)
                   (call-interactively ,normal-command))))
             (define-key ,keymap ,key #',command-name))))

      (defun stop-drag ()
        "Stop drag, just something print, and nothing do, set to nil something."
        (interactive)
        (setq my-last-command-is-drag-stuff nil)
        (message "Turn `drag' to normal!"))

      (define-key-when
          my-insert-new-line-or-nothing
          xah-fly-command-map
        ""
        'stop-drag
        'my-last-command-is-dragged-stuff-p)

      (my-define-stuff-key
       xah-fly-command-map
       "j"
       #'backward-char
       #'my-drag-stuff-left-char)

      (my-define-stuff-key
       xah-fly-command-map
       "l"
       #'forward-char
       #'my-drag-stuff-right-char)

      (my-define-stuff-key
       xah-fly-command-map
       "o"
       #'syntax-subword-forward
       #'my-drag-stuff-right)

      (my-define-stuff-key
       xah-fly-command-map
       "u"
       #'syntax-subword-backward
       #'my-drag-stuff-left)

      (my-define-stuff-key
       xah-fly-command-map
       "i"
       #'previous-line
       #'my-drag-stuff-up)

      (my-define-stuff-key
       xah-fly-command-map
       "k"
       #'next-line
       #'my-drag-stuff-down)
        #+END_SRC

  I also need to define key for usage, here also define other tranpose
  commands:

  #+BEGIN_SRC emacs-lisp :tangle ~/init.el

    (use-package drag-stuff
        :ensure t
        :config
        (drag-stuff-global-mode t)
        :bind
        ((:map xah-fly-command-map)
         ("SPC TAB j" . 'my-drag-stuff-left-char)
         ("SPC TAB l" . 'my-drag-stuff-right-char)
         ("SPC TAB i" . 'my-drag-stuff-up)
         ("SPC TAB k" . 'my-drag-stuff-down)
         ("SPC TAB o" . 'my-drag-stuff-right)
         ("SPC TAB u" . 'my-drag-stuff-left)
         ("SPC TAB ." . 'transpose-sexps)
         ("SPC TAB m" . 'transpose-sexps)
         ("SPC TAB n" . 'avy-transpose-lines-in-region)
         ("SPC TAB t" . 'transpose-regions)))

  #+END_SRC

*** Draggers of =drag-stuff=
    I am use [[https://github.com/rejeep/drag-stuff.el][drag-stuff]], and my [[*Define Extensible Drag System][drag system]]:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el
      (add-left-dragger  #'drag-stuff-left)
      (add-right-dragger #'drag-stuff-right)
      (add-up-dragger    #'drag-stuff-up)
      (add-down-dragger  #'drag-stuff-down)
    #+END_SRC

*** Draggers for =org-mode=
    I am use [[*Define Extensible Drag System][my drag system]] and built in =org= functions:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (defun my-org-mode-in-heading-start-p ()
         "Return t, when current position now in start of org's heading."
         (interactive "d")
         (and
          (not (org-in-src-block-p))
          (my-current-line-prefix-p "*")))

       (defun my-drag-org-heading-right ()
         "Drag Org's heading to right."
         (interactive)
         (when (and
                (eq major-mode 'org-mode)
                (or
                 (my-org-mode-in-heading-start-p)
                 (org-at-table-p)))
           (org-metaright)
           t))

       (defun my-drag-org-heading-left ()
         "Drag Org's heading to left."
         (interactive)
         (when (and
                (eq major-mode 'org-mode)
                (or
                 (my-org-mode-in-heading-start-p)
                 (org-at-table-p)))
           (org-metaleft)
           t))

       (defun my-drag-org-heading-up ()
         "Drag Org's heading to up."
         (interactive)
         (when (and
                (eq major-mode 'org-mode)
                (or
                 (my-org-mode-in-heading-start-p)
                 (org-at-table-p)))
           (org-metaup)
           t))

       (defun my-drag-org-heading-down ()
         "Drag Org's heading to down."
         (interactive)
         (when (or
                (org-at-table-p)
                (my-org-mode-in-heading-start-p))
           (org-metadown)
           t))

       (add-right-dragger #'my-drag-org-heading-right)
       (add-left-dragger #'my-drag-org-heading-left)
       (add-down-dragger #'my-drag-org-heading-down)
       (add-up-dragger #'my-drag-org-heading-up)

     #+END_SRC

** Custom Deleting Text
   I am delete this line and edit this by press =w=:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defun delete-and-edit-current-line ()
       "Delete current line and instroduce to insert mode."
       (interactive)
       (beginning-of-line-text)
       (kill-line)
       (xah-fly-insert-mode-init)
       )

     (define-key xah-fly-command-map (kbd "w") 'delete-and-edit-current-line)

     #+END_SRC

   I am delete content of this line (including whitespaces) on press =SPC w=:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defun clear-current-line ()
       "Clear content of current line (including whitespaces)."
       (interactive)
       (kill-region (line-beginning-position) (line-end-position))
       )

     (define-key xah-fly-command-map (kbd "SPC w") 'clear-current-line)
     #+END_SRC

** Custom Selecting Text
   I am press 2 times =8= for selecting 2 words

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el
     (defun select-current-or-next-word ()
       "If word was selected, then move to next word, otherwise select word."
       (interactive)
       (if (use-region-p)
           (forward-word)
         (xah-extend-selection))
       )

     (define-key xah-fly-command-map (kbd "8") 'select-current-or-next-word)

   #+END_SRC

   I am press =g=, for deleting current block, but if selected region, then I am cancel
   this select:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defun delete-current-text-block-or-cancel-selection ()
       "If text is selected, then cancel selection, otherwise delete current block."
       (interactive)
       (if (use-region-p)
           (deactivate-mark)
         (xah-delete-current-text-block)))

     (define-key xah-fly-command-map (kbd "g") nil)
     (define-key xah-fly-command-map (kbd "g") 'delete-current-text-block-or-cancel-selection)

   #+END_SRC

   I am press =-= for change position when select text to begin/end of selected region:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (define-key-when
         my-exchange-point-and-mark-or-splice-sexp
         xah-fly-command-map
       "-"
       'exchange-point-and-mark
       'use-region-p)

     #+END_SRC

** Custom Editing Text
   I am use =s= for inserting new line:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defun open-line-saving-indent ()
       "Inserting new line, saving position and inserting new line."
       (interactive)
       (newline)
       (unless (s-blank-p (s-trim (thing-at-point 'line t)))
         (indent-according-to-mode))
       (forward-line -1)
       (end-of-line)
       (delete-horizontal-space t))

     (define-key xah-fly-command-map (kbd "s") 'open-line-saving-indent)

     #+END_SRC

   And =SPC s= for new line below and =SPC SPC s= for new line above:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defun open-line-below ()
       (interactive)
       (end-of-line)
       (newline)
       (indent-for-tab-command))

     (defun open-line-above ()
       (interactive)
       (beginning-of-line)
       (newline)
       (forward-line -1)
       (indent-for-tab-command))

     (defun new-line-in-between ()
       (interactive)
       (newline)
       (save-excursion
         (newline)
         (indent-for-tab-command))
       (indent-for-tab-command))

     (defun duplicate-current-line-or-region (arg)
       "Duplicates the current line or region ARG times.
     If there's no region, the current line will be duplicated."
       (interactive "p")
       (if (region-active-p)
           (let ((beg (region-beginning))
                 (end (region-end)))
             (duplicate-region arg beg end)
             (one-shot-keybinding "d" (λ (duplicate-region 1 beg end))))
         (duplicate-current-line arg)
         (one-shot-keybinding "d" 'duplicate-current-line)))

     (defun one-shot-keybinding (key command)
       (set-temporary-overlay-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd key) command)
          map) t))

     (defun replace-region-by (fn)
       (let* ((beg (region-beginning))
              (end (region-end))
              (contents (buffer-substring beg end)))
         (delete-region beg end)
         (insert (funcall fn contents))))

     (defun duplicate-region (&optional num start end)
       "Duplicates the region bounded by START and END NUM times.
     If no START and END is provided, the current region-beginning and
     region-end is used."
       (interactive "p")
       (save-excursion
         (let* ((start (or start (region-beginning)))
                (end (or end (region-end)))
                (region (buffer-substring start end)))
           (goto-char end)
           (dotimes (i num)
             (insert region)))))

     (defun paredit-duplicate-current-line ()
       (back-to-indentation)
       (let (kill-ring kill-ring-yank-pointer)
         (paredit-kill)
         (yank)
         (newline-and-indent)
         (yank)))

     (defun duplicate-current-line (&optional num)
       "Duplicate the current line NUM times."
       (interactive "p")
       (if (bound-and-true-p paredit-mode)
           (paredit-duplicate-current-line)
         (save-excursion
           (when (eq (point-at-eol) (point-max))
             (goto-char (point-max))
             (newline)
             (forward-char -1))
           (duplicate-region num (point-at-bol) (1+ (point-at-eol))))))

     (defvar yank-indent-modes '(prog-mode
                                 sgml-mode
                                 js2-mode)
       "Modes in which to indent regions that are yanked (or yank-popped)")

     (defvar yank-advised-indent-threshold 1000
       "Threshold (# chars) over which indentation does not automatically occur.")

     (defun yank-advised-indent-function (beg end)
       "Do indentation, as long as the region isn't too large."
       (if (<= (- end beg) yank-advised-indent-threshold)
           (indent-region beg end nil)))

     (defadvice yank (after yank-indent activate)
       "If current mode is one of 'yank-indent-modes, indent yanked text.
     With prefix arg don't indent."
       (if (and (not (ad-get-arg 0))
                (--any? (derived-mode-p it) yank-indent-modes))
           (let ((transient-mark-mode nil))
             (yank-advised-indent-function (region-beginning) (region-end)))))

     (defadvice yank-pop (after yank-pop-indent activate)
       "If current mode is one of 'yank-indent-modes, indent yanked text.
     With prefix arg don't indent."
       (if (and (not (ad-get-arg 0))
                (member major-mode yank-indent-modes))
           (let ((transient-mark-mode nil))
             (yank-advised-indent-function (region-beginning) (region-end)))))

     (defun yank-unindented ()
       (interactive)
       (yank 1))

     (defun kill-to-beginning-of-line ()
       (interactive)
       (kill-region (save-excursion (beginning-of-line) (point))
                    (point)))

     (bind-keys :map
                xah-fly-command-map
                ("SPC y"     . duplicate-current-line-or-region)
                ("SPC s"     . open-line-below)
                ("SPC e"     . kill-to-beginning-of-line)
                ("SPC k RET" . new-line-in-between)
                ("SPC SPC s" . open-line-above))

   #+END_SRC

   I am use =SPC b= to change case of current line:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defun my-change-case-of-current-line ()
       "Change case of current line to next (see `xah-toggle-letter-case')."
       (interactive)
       (save-mark-and-excursion
         (select-current-line)
         (xah-toggle-letter-case)))

     (bind-keys
      :map xah-fly-command-map
      ("SPC SPC b" . my-change-case-of-current-line)
      ("b"         . my-toggle-change-case-of-line-or-word-or-selection))

     (defvar my-last-command-is-changed-case-of-current-line
       nil "In t, when last command change case.")

     (defun my-toggle-change-case-of-line-or-word-or-selection ()
       "Using one of functions, which change case.
     List of functions: `xah-toggle-letter-case', `my-change-case-of-current-line'."
       (interactive)
       (let* ((change-case-of-line
               (or
                (eq last-command 'my-change-case-of-current-line)
                (and
                 (eq
                  last-command
                  'my-toggle-change-case-of-line-or-word-or-selection)
                 my-last-command-is-changed-case-of-current-line))))
         (setq my-last-command-is-changed-case-of-current-line change-case-of-line)
         (if change-case-of-line
             (my-change-case-of-current-line)
           (xah-toggle-letter-case))))

   #+END_SRC


   And I am press =p= for inserting space, and if I am selected region,  for inserting space
   to beginning of each line:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defun insert-space-before-line ()
       "Saving position, insert space to beginning of current line."
       (interactive)
       (save-excursion (beginning-of-line-text)
                       (xah-insert-space-before))
       )

     (defun insert-spaces-before-each-line-by-line-nums (start-line end-line)
       "Insert space before each line in region (`START-LINE`; `END-LINE`)."
       (unless (= 0 (+ 1 (- end-line start-line)))
         (goto-line start-line)
         (insert-space-before-line)
         (insert-spaces-before-each-line-by-line-nums (+ start-line 1) end-line))
       )

     (defun insert-spaces-before-each-line (beg end)
       "Insert spaces before each selected line, selected line indentifier with `BEG` & `END`."
       (interactive "r")
       (save-excursion
         (let (deactivate-mark)
           (let ((begining-line-num (line-number-at-pos beg))
                 (end-line-num (line-number-at-pos end)))
             (insert-spaces-before-each-line-by-line-nums begining-line-num end-line-num))))
       )

     (defun insert-spaces-before-or-to-beginning-of-each-line (beg end)
       "Insert space, and if selected region, insert space to beginning of each line, text is should will indentifier with `BEG` & `END`."
       (interactive (list (if (use-region-p) (region-beginning))
                          (if (use-region-p) (region-end))))
       (if (use-region-p)
           (insert-spaces-before-each-line beg end)
         (xah-insert-space-before))
       )

     (define-key xah-fly-command-map (kbd "p") nil)
     (define-key xah-fly-command-map (kbd "p") 'insert-spaces-before-or-to-beginning-of-each-line)

     #+END_SRC

     I press =SPC k 6= and Emacs duplicate last text block:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (defun my-duplicate-last-bloc ()
         "Take last text block and insert."
         (interactive)
         (->>
          (buffer-substring (my-point-at-last-block-beg) (point))
          (s-trim)
          (s-append "\n")
          (s-prepend "\n")
          (insert)))

       (defun my-point-at-last-block-beg ()
         "Move to beginning of last block and return current position of cursor."
         (interactive)
         (save-excursion
           (cond
             ((not (re-search-backward "\\w" nil nil)) (point-min))
             ((re-search-backward "\n[\t\n ]*\n+" nil 1)
              (skip-chars-backward "\n\t ")
              (point))
             (t (point-min)))))

       (bind-keys*
        :map xah-fly-command-map
        ("SPC k 6" . my-duplicate-last-bloc))
     #+END_SRC

** Custom Navigation
   I am press =m= and =.= for go to next, previous sexp:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (define-key xah-fly-command-map (kbd "m") 'backward-sexp)
     (define-key xah-fly-command-map (kbd ".") 'forward-sexp)

     #+END_SRC

** Rectangles

   I am press =SPC t= for enable =rectangle-mark-mode=, and =f= when =rectangle-mark-mode=
   is enabled for replace rectangle:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el
     (require 'rect)

     (define-key xah-fly-command-map (kbd "SPC t") 'rectangle-mark-mode)
     (define-key xah-fly-command-map (kbd "SPC v") 'yank-rectangle)

     (defun rectangle-mark-mode-p ()
       "Return t, when `rectangle-mark-mode' is enabled."
       rectangle-mark-mode)

     (define-key-when
         my-copy-rectangle-or-copy-line
         xah-fly-command-map
         "c"
       'copy-rectangle-as-kill
       'rectangle-mark-mode-p)

     (define-key-when
         my-kill-rectangle-or-delete-char
         xah-fly-command-map
         "d"
       'kill-rectangle
       'rectangle-mark-mode-p)

     (define-key-when
         my-kill-rectangle-or-kill-line
         xah-fly-command-map
       "x"
       'kill-rectangle
       'rectangle-mark-mode-p)

     (define-key-when
         my-xah-activate-insert-mode-or-replace-rectangle
         xah-fly-command-map
       "f"
       'replace-rectangle
       'rectangle-mark-mode-p)

     (define-key-when
         any-exchange-point-and-mark-or-splice-sexp
         xah-fly-command-map
       "-"
       'rectangle-exchange-point-and-mark
       'rectangle-mark-mode-p)

     ;;

                      #+END_SRC

** Indent Settings

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (setq-default indent-tabs-mode nil)
     (setq-default tab-width          4)
     (setq-default c-basic-offset     4)
     (setq-default standart-indent    4)
     (setq-default lisp-body-indent   4)

     (defun select-current-line ()
       "Select as region current line."
       (interactive)
       (forward-line 0)
       (set-mark (point))
       (end-of-line)
       )

     (defun indent-line-or-region ()
       "If text selected, then indent it, otherwise indent current line."
       (interactive)
       (save-excursion
         (if (use-region-p)
             (indent-region (region-beginning) (region-end))
           (funcall indent-line-function)
           ))
       )

     (global-set-key (kbd "RET") 'newline-and-indent)
     (define-key xah-fly-command-map (kbd "q") 'indent-line-or-region)
     (define-key xah-fly-command-map (kbd "SPC q") 'join-line)

     (setq lisp-indent-function  'common-lisp-indent-function)

     #+END_SRC

   I am press =SPC , ,= for go to defnition:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (define-key xah-fly-command-map (kbd "SPC .") 'xref-find-definitions)

     #+END_SRC
     
* Support of Languages
** Functions for extending functional of language
*** Functions for Navigation
    Function `add-nav-to-imports-for-language`, is define keys for go to imports:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (defmacro add-nav-to-imports-for-language (language to-imports-function)
        "Bind `TO-IMPORTS-FUNCTION` to `LANGUAGE`-map."
        `(let ((language-hook (intern (s-append "-hook" (symbol-name ',language)))))
           (add-hook
            language-hook
            (lambda ()
              (define-key
                  xah-fly-command-map
                  (kbd "SPC SPC i")
                ',to-imports-function)))))

                #+END_SRC

*** Functions for Pretty View
    I am use [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]] for centering content of org file:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el
      (require 'face-remap)

      (use-package visual-fill-column
          :ensure t)

      (defun visual-fill (&optional width)
        (interactive)
        (or width (setq width 70))
        (setq-default visual-fill-column-width width
                      visual-fill-column-center-text t)
        (text-scale-mode 0)
        (visual-fill-column-mode 1))
        #+END_SRC

*** Functions for Import
    Function `add-import-keymap-for-language` defines key for `add-import`.

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el
      (defmacro add-import-keymap-for-language (language add-import-function)
        "Bind `ADD-IMPORT-FUNCTION` to `LANGUAGE`-map."
        `(let ((language-hook (intern (s-append "-hook" (symbol-name ',language)))))
           (add-hook
            language-hook
            (lambda ()
              (define-key
                  xah-fly-command-map
                  (kbd "SPC i")
                ',add-import-function)))))

                #+END_SRC

*** Functions for Auto Format Code
    I am take this from [[https://github.com/jkitchin/scimax/][scimax]]:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (defvar my-autoformat-functions nil
        "Current used autoformat functions.")

      (defcustom my-autoformat-all-functions
        '(sentence-capitalization)
        "All my autoformat functions.")

      (defun my-use-autoformat-function-p (f)
        "Return t, when must use F as autoformat function."
        (-contains-p my-autoformat-functions f))

      (defmacro my-use-autoformat-in-mode (mode &rest autoformat-functions)
        "Add hook to MODE, which enable AUTOFORMAT-FUNCTIONS."
        (let* ((hook
                (intern (s-append "-hook" (symbol-name (eval mode)))))
               (funcs
                (->>
                 autoformat-functions
                 (--map (symbol-name it))
                 (--map (intern (s-prepend "autoformat-" it))))))
          `(add-hook ',hook
                     (lambda ()
                       (setq-local my-autoformat-functions ',funcs)))))

      (defmacro my-use-all-autoformat-in-mode (mode)
        "Use my all autoformat functions in MODE."
        `(my-use-autoformat-in-mode ,mode ,@my-autoformat-all-functions))

      (defun autoformat-sentence-capitalization ()
        "Auto-capitalize first words of a sentence.
      Either at the beginning of a line, or after a sentence end."
        (interactive)
        (when (and
               (my-use-autoformat-function-p 'autoformat-sentence-capitalization)
               (my-in-text-p)
               (looking-back "[а-яa-z]")
               (save-excursion
                 (forward-char -1)
                 (or
                  (looking-back (sentence-end))
                  (bobp)
                  (and
                   (skip-chars-backward " ")
                   (bolp)
                   (my-previous-line-is-empty))
                  (and
                   (skip-chars-backward " ")
                   (< (skip-chars-backward "*") 0)
                   (bolp)))))
          (undo-boundary)
          (capitalize-word -1)))

      (defun my-previous-line-is-empty ()
        "Move to previous line and return t, when this line is empty.
      \\(see `my-current-line-is-empty-p')"
        (forward-line -1)
        (my-current-line-is-empty-p))

      (defun my-in-text-p ()
        "Return t, when cursor has position on common text."
        (and (not (org-in-src-block-p)) (not (texmathp))))

      (defun my-autoformat ()
        "Call all autoformat functions."
        (interactive)
        (--each my-autoformat-functions (funcall it)))

      (define-minor-mode my-autoformat-mode
          "Toggle `my-autoformat-mode'.  Converts 1st to 1^{st} as you type."
        :init-value nil
        (if my-autoformat-mode
            (add-hook 'post-self-insert-hook #'my-autoformat)
          (remove-hook 'post-self-insert-hook #'my-autoformat)))

      (my-autoformat-mode t)
    #+END_SRC

    #+RESULTS:
    : t

** Supported Languages
*** LaTeX
    I am use [[https://github.com/emacsmirror/auctex][auctex]], I am take some configuration from
    [[https://habr.com/ru/company/skillfactory/blog/593999/][this article from HABR]]:

    Main skeleton of my LaTeX configuration is package =tex-mode= with
    =LaTeX-mode= and =AucTeX=:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package tex-mode
          :major-mode-map latex (LaTeX-mode))

    #+END_SRC

**** LaTeX + calc
     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package latex
           :ensure auctex
           :hook ((LaTeX-mode . prettify-symbols-mode))
           :bind ((:map my-latex-local-map)
                  ("="     . my-calc-simplify-region-copy)
                  ("f"     . my-calc-simplify-region-change))
           :config (require 'calc-lang)
           (defun my-calc-simplify (expr)
             "Simplify EXPR via `calc' and return this."
             (calc-latex-language t)
             (calc-alg-entry expr)
             (with-temp-buffer
               (calc-copy-to-buffer 1)
               (delete-char -1)
               (buffer-string)))

           (defun my-calc-simplify-region-copy (beg end)
             "Take from BEG to END, simplify this via `calc' and copy as kill."
             (interactive "r")
             (let ((expr (my-calc-simplify (buffer-substring beg end))))
               (kill-new expr)
               (message "coppied: %s" (current-kill 0))))

           (defun my-calc-simplify-region-change (beg end)
             "Get from BEG to END change this via `calc' and yank instead of region."
             (interactive "r")
             (let ((expr (buffer-substring beg end)))
               (goto-char beg)
               (delete-region beg end)
               (insert (my-calc-simplify expr)))))

      #+END_SRC

**** Preview Latex

     I am use =math-preview= which via [[https://docs.mathjax.org/][MathJax]] preview =LaTeX= source
     code inline.  Before use =math-preview= you must install external
     programm via =npm=

     #+BEGIN_SRC shell
       npm install -g git+https://gitlab.com/matsievskiysv/math-preview
     #+END_SRC


     #+BEGIN_SRC emacs-lisp :tangle ~/init.el
       (use-package math-preview
           :ensure t
           :custom
           (math-preview-preprocess-functions
            (list (lambda (s) (s-concat "{\\color{white}" s "}"))))
           :bind ((:map my-latex-local-map)
                  ("p" . 'my-latex-preview)
                  ("d" . 'math-preview-clear-at-point)))

       (defun my-latex-preview ()
         "Preview latex fragments combine `org-latex-combine', `math-preview'."
         (interactive)
         (if (->> (math-preview--find-gaps (point-min) (point-max))
                  (--filter (and (>= (point) (car it))
                                 (< (point) (cdr it))))
                  (--map (math-preview--search (car it) (cdr it)))
                  (-flatten)
                  (--filter (and (>= (point) (car it))
                                 (< (point) (cdr it)))))
             (math-preview-at-point)
           (org-latex-preview)))

     #+END_SRC

**** Fast Navigation and Insertion in LaTeX

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package cdlatex
           :ensure t
           :hook (LaTeX-mode . turn-on-cdlatex)
           :defer t
           :bind (:map cdlatex-mode-map ("<tab>" . cdlatex-tab)))

       ;; fields
       (use-package cdlatex
           :hook ((cdlatex-tab . yas-expand)
                  (cdlatex-tab . cdlatex-in-yas-field))
           :custom (cdlatex-math-modify-alist
                    '((?q "\\sqrt" nil t nil nil))))

       (use-package yasnippet
           :bind ((:map yas-keymap)
                  ("<tab>" . yas-next-field-or-cdlatex)
                  ("TAB" . yas-next-field-or-cdlatex))
           :config ;nofmt
           (defun cdlatex-in-yas-field ()
               (when-let* ((_ (overlayp yas--active-field-overlay))
                           (end (overlay-end yas--active-field-overlay)))
                   (if (>= (point) end)
                       (let ((s (thing-at-point 'sexp)))
                           (unless (and s
                                        (assoc
                                         (substring-no-properties s)
                                         cdlatex-command-alist-comb))
                               (yas-next-field-or-maybe-expand)
                               t))
                       (let (cdlatex-tab-hook minp)
                           (setq minp
                                 (min
                                  (save-excursion
                                      (cdlatex-tab)
                                      (point))
                                  (overlay-end
                                   yas--active-field-overlay)))
                           (goto-char minp)
                           t))))

           (defun yas-next-field-or-cdlatex nil
               (interactive)
               "Jump to the next Yas field correctly with cdlatex active."
               (if (or
                    (bound-and-true-p cdlatex-mode)
                    (bound-and-true-p org-cdlatex-mode))
                   (cdlatex-tab)
                   (yas-next-field-or-maybe-expand))))
     #+END_SRC

**** Insert Pairs in LaTeX
     =CDLaTeX= rebind some keymaps of =smartparens= to more stupid
     alternatives, so I rebind its back:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package tex-mode
           :after cdlatex
           :bind
           ((:map cdlatex-mode-map)
            ("(" . self-insert-command)
            (")" . self-insert-command)
            ("{" . self-insert-command)
            ("}" . self-insert-command)
            ("[" . self-insert-command)
            ("]" . self-insert-command)
            ("\\" . self-insert-command)))

     #+END_SRC

     Also beacause I am Russian, i need press =;= in =Russian=
     keyboard and Emacs should insert pairs of dollars and toggle
     input method

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (defun my-latex-dollar ()
         "Insert dollars and toggle input method to russian."
         (interactive)
         (when current-input-method (toggle-input-method))
         (if (use-region-p)
             (sp-wrap-with-pair "$")
           (insert "$$")
           (forward-char -1)))

       (use-package cdlatex
           :ensure t
           :bind
           (:map cdlatex-mode-map)
           (";" . my-latex-dollar)
           ("$" . my-latex-dollar))

     #+END_SRC

**** LaTeX Tables

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       ;; Array/tabular input with org-tables and cdlatex
       (use-package org-table
           :after cdlatex
           :bind (:map orgtbl-mode-map
                       ("<tab>" . lazytab-org-table-next-field-maybe)
                       ("TAB" . lazytab-org-table-next-field-maybe))
           :init (add-hook 'cdlatex-tab-hook 'lazytab-cdlatex-or-orgtbl-next-field 90)
           ;; Tabular environments using cdlatex
           (add-to-list 'cdlatex-command-alist
                        '("smat" "Insert smallmatrix env"
                          "\\left( \\begin{smallmatrix} ? \\end{smallmatrix} \\right)"
                          lazytab-position-cursor-and-edit
                          nil nil t))
           (add-to-list 'cdlatex-command-alist
                        '("bmat" "Insert bmatrix env"
                          "\\begin{bmatrix} ? \\end{bmatrix}"
                          lazytab-position-cursor-and-edit
                          nil nil t))
           (add-to-list 'cdlatex-command-alist
                        '("pmat" "Insert pmatrix env"
                          "\\begin{pmatrix} ? \\end{pmatrix}"
                          lazytab-position-cursor-and-edit
                          nil nil t))
           (add-to-list 'cdlatex-command-alist
                        '("tbl" "Insert table"
                          "\\begin{table}\n\\centering ? \\caption{}\n\\end{table}\n"
                          lazytab-position-cursor-and-edit
                          nil t nil))
           :config ;; Tab handling in org tables
           (defun lazytab-position-cursor-and-edit ()
             ;; (if (search-backward "\?" (- (point) 100) t)
             ;;     (delete-char 1))
             (cdlatex-position-cursor)
             (lazytab-orgtbl-edit))

           (defun lazytab-orgtbl-edit ()
             (advice-add 'orgtbl-ctrl-c-ctrl-c :after #'lazytab-orgtbl-replace)
             (orgtbl-mode 1)
             (open-line 1)
             (insert "\n|"))

           (defun lazytab-orgtbl-replace (_)
             (interactive "P")
             (unless (org-at-table-p) (user-error "Not at a table"))
             (let* ((table (org-table-to-lisp))
                    params
                    (replacement-table
                     (if (texmathp)
                         (lazytab-orgtbl-to-amsmath table params)
                       (orgtbl-to-latex table params))))
               (kill-region (org-table-begin) (org-table-end))
               (open-line 1)
               (push-mark)
               (insert replacement-table)
               (align-regexp
                (region-beginning)
                (region-end)
                "\\([:space:]*\\)& ")
               (orgtbl-mode -1)
               (advice-remove 'orgtbl-ctrl-c-ctrl-c #'lazytab-orgtbl-replace)))

           (defun lazytab-orgtbl-to-amsmath (table params)
             (orgtbl-to-generic
              table
              (org-combine-plists
               '(:splice t
                 :lstart ""
                 :lend " \\\\"
                 :sep " & "
                 :hline nil
                 :llend "")
               params)))

           (defun lazytab-cdlatex-or-orgtbl-next-field ()
             (when (and
                    (bound-and-true-p orgtbl-mode)
                    (org-table-p)
                    (looking-at "[[:space:]]*\\(?:|\\|$\\)")
                    (let ((s (thing-at-point 'sexp)))
                      (not (and s (assoc s cdlatex-command-alist-comb)))))
               (call-interactively #'org-table-next-field)
               t))

           (defun lazytab-org-table-next-field-maybe ()
             (interactive)
             (if (bound-and-true-p cdlatex-mode)
                 (cdlatex-tab)
               (org-table-next-field))))

               #+END_SRC

**** Variables for LaTeX
     Variable `latex-documentclasses` is list of documentclasses in Emacs, each element
     of this list is name of documentclass in lower case. Defaults to:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el
       (setq latex-documentclasses
             '("article" "reoport" "book" "proc" "minimal" "slides" "memoir" "letter" "beamer"))
             #+END_SRC

**** Visual Fill for LaTeX

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (dolist (mode (list 'TeX-mode-hook
                           'tex-mode-hook
                           'latex-mode-hook
                           'LaTeX-mode-hook))
         (add-hook mode (lambda () (call-interactively 'visual-fill))))

         #+END_SRC
**** Keymaps for LaTeX
     I am russian, and on my native keyboard =;= is =$=:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package latex
           :major-mode-map (TeX-mode LaTeX-mode tex-mode latex-mode)
           :bind ((:map LaTeX-mode-map)
                  (";" . cdlatex-dollar)))

     #+END_SRC
**** Auto Complete for LaTeX
     I am use [[https://github.com/vspinu/company-math][company-math]] and [[https://github.com/alexeyr/company-auctex][company-auctex]]:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package company-math
           :ensure t
           :init
           (defun my-company-math-setup ()
             "Setup for `company-math'."
             (add-to-list 'company-backends 'company-math-symbols-latex)
             (add-to-list 'company-backends 'company-latex-commands))
           (add-hook 'LaTeX-mode 'my-company-math-setup))

       (use-package company-auctex
           :ensure t
           :config
           (company-auctex-init))

           #+END_SRC
**** Auto Activating Snippets for LaTeX
     I am use [[https://github.com/tecosaur/LaTeX-auto-activating-snippets][LaTeX-auto-activating-snippets]]. I am use some standard
     snippets, but also I need to some things, which will expands as
     units, for example /Om/ will be expanded to /\mathrm{Ом}/:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package laas
           :ensure t
           :hook (LaTeX-mode . laas-mode)
           :config
           (aas-set-snippets 'laas-mode
             ".," ";"
             :cond #'texmathp
             ;; Some Units
             "As" "\\mathrm{А}"
             "Vs"  "\\mathrm{В}"
             "Oms"  "\\mathrm{Ом}"
             "cls" "^\\circ C"

             ;; Some Physics Sheet
             "eqv" "\\mathrm{экв}"

             ;; Some Cool Symbols
             "is" "\\Leftrightarrow"
             "trg" "\\triangle"
             "agl" "\\angle"
             "grd" "^\\circ"))

     #+END_SRC
**** Auto Format in LaTeX
     I am use my own [[*Functions for Auto Format Code]] to auto format in
     =LaTeX=:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (eval
        `(my-use-autoformat-in-mode
          'LaTeX-mode
          ,@(cons 'latex-capitalize-special-commands my-autoformat-all-functions)))

       (defvar autoformat-latex-capitalize-latex-commands
         '("author" "title" "date" "part" "subsection" "section" "part" "chapter")
         "List of regexps which Emacs will automatically capitalize.")

       (defvar autoformat-latex-capitalize-regexps
         (--map
          (s-concat "\\\\" it "\\W*{.")
          autoformat-latex-capitalize-latex-commands)
         "List of regexps which Emacs will automatically capitalize.")

       (add-to-list 'autoformat-latex-capitalize-regexps "\\\\item\\W+.")

       (defun autoformat-latex-capitalize-special-commands ()
         "Capitalize last symbol, when its match on special regexp."
         (interactive)
         (when (-any #'looking-back autoformat-latex-capitalize-regexps)
           (undo-boundary)
           (capitalize-word -1)))

     #+END_SRC
**** Equation Environment to Split Environment
     I must has funcion which take current equation environment and
     transformt its to split environment

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (defun my-latex-equation-to-split ()
         "Transform LaTeX equation environment to split environment."
         (interactive)
         (save-excursion
           (LaTeX-find-matching-begin)
           (end-of-line)
           (push-mark)
           (LaTeX-find-matching-end)
           (beginning-of-line)
           (cdlatex-wrap-environment "split")
           (indent-region (region-beginning) (region-end))
           (replace-string "=" "&=" nil (region-beginning) (region-end))
           (LaTeX-find-matching-begin)
           (forward-line)
           (kill-whole-line)
           (forward-line)
           (end-of-line)
           (--dotimes
               (- (save-excursion
                    (LaTeX-find-matching-end)
                    (line-number-at-pos))
                  (line-number-at-pos))
             (end-of-line)
             (insert "\\\\")
             (forward-line))))


       (bind-keys*
        :map my-latex-local-map
        ("\\" . my-latex-equation-to-split))


     #+END_SRC
**** Insert any image at URL in LaTeX
     I am as old user of =Google.Documents= must have command which
     just insert any image by url, so I create its.  For insert a
     image at url I bind keymaps to =SPC l i= (insert a image at
     readed from the minibuffer url) and snippet =uimg= (insert a
     image from the clipboard)

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (defun my-latex-insert-img-at-copied-url (&optional image-name)
         "Insert to current LaTeX buffer image at URL which copied in clipboard.
       If copied text isn't URL then report the error.  Downloaded file will be called
       IMAGE-NAME."
         (interactive)
         (let ((url (current-kill 0)))
           (when (interactive-p)
             (setq image-name
                   (read-string "Name of downloaded image, please: "
                                (my-uri-of-url url))))
           (my-latex-insert-img-at-url url image-name)))

       (defun my-latex-insert-img-at-url (url &optional image-name)
         "Insert to current latex buffer image at URL, install if need.
       Downloaded image will be called IMAGE-NAME"
         (interactive
          (let* ((url (read-string "Enter URL for image, please: "))
                 (image-name
                  (read-string
                   "Name of downloaded image,  please: "
                   (my-uri-of-url url))))
            (list url image-name)))
         (my-latex-graphics-init)
         (->>
          (my-latex-download-image-into-graphicspath url image-name)
          (my-latex-insert-img-at-path)))

       (defun my-latex-graphics-init ()
         "Add some stuffs for graphics in LaTeX."
         (interactive)
         (my-latex-use-package "graphicx")
         (unless (my-latex-current-graphicspathes)
           (my-latex-add-graphicspath "./images/")))

       (defun my-latex-insert-img-at-path (path)
         "Insert to current latex buffer image at PATH."
         (->>
          path
          (f-base)
          (format "\\begin{center}
         \\includegraphics{%s}
       \\end{center}")
          (insert)))

       (defun my-latex-download-image-into-graphicspath (url &optional filename)
         "Download image at URL into graphicspath of current LaTeX buffer.
       This file has name FILENAME.  Return nil when fail, otherwise return path of
       downloaded file"
         (or filename (setq filename (my-uri-of-url)))
         (let* ((graphicspath (-last-item (my-latex-current-graphicspathes)))
                (dest (f-join graphicspath filename)))
           (url-copy-file url dest t)
           dest))

       (defun my-uri-of-url (url)
         "Get the URI of URL."
         (->>
          url
          (s-split "/")
          (-last-item)
          (s-split "?")
          (-first-item)))

       (defun my-latex-add-graphicspath (path)
         "Add to list of current LaTeX file' s graphicpath PATH."
         (->>
          (my-latex-current-graphicspathes)
          (cons path)
          (my-latex-set-graphicspath)))

       (defun my-latex-set-graphicspath (paths)
         "Set graphicpath (command \\graphicspath)of current LaTeX buffer to PATHS."
         (save-excursion
           (my-latex-goto-graphicspath)
           (forward-char -1)
           (sp-get
               (sp-get-enclosing-sexp)
             (delete-region :beg-in :end-in)
             (--each paths (insert (format "{%s}" it))))))

       (defun my-latex-current-graphicspathes ()
         "Parse from current LaTeX buffer value of \\graphicspath."
         (save-excursion
           (my-latex-goto-graphicspath)
           (forward-char -1)
           (sp-get
               (sp-get-enclosing-sexp)
             (->>
              (buffer-substring-no-properties :beg-in :end-in)
              (s-match-strings-all "\{\\([^\\}]*\\)\}")
              (-map #'-last-item)))))

       (defun my-latex-goto-graphicspath ()
         "Goto end of LaTeX command for set graphic paths, if isn't exit insert."
         (goto-char (point-min))
         (unless (search-forward-regexp "^\\\\graphicspath\\W*\{.*\}\\W*$"  nil t)
           (search-forward-regexp "\\\\begin\\W*\{\\W*document\\W*\}"  nil t)
           (forward-line -1)
           (end-of-line)
           (newline)
           (insert "\\graphicspath{}")))

       (defun my-latex-use-package (package &optional options)
         "Add \\usepackage for PACKAGE with OPTIONS to current LaTeX buffer."
         (interactive "sPlease, choose package which you need use: ")
         (unless (my-latex-used-package-p package)
           (save-excursion
             (goto-char (point-min))
             (search-forward-regexp "^\\\\usepackage" nil t)
             (beginning-of-line)
             (insert "\\usepackage")
             (LaTeX-arg-usepackage-insert (list package) options)
             (LaTeX-newline))))

       (defun my-latex-used-package-p (package)
         "Return t, when PACKAGE was used in current LaTeX buffer."
         (-contains-p (my-latex-used-packages) package))

       (defun my-latex-used-packages ()
         "Parse from current LaTeX buffer, list of used packages."
         (->>
          (buffer-string)
          (s-lines)
          (--filter (s-prefix-p "\\usepackage" it))
          (--map
           (-last-item
            (s-match "\\\\usepaIckage\\(\\[.*\\]\\)?{\\(.*\\)}" it)))))

       (bind-keys
        :map my-latex-local-map
        ("i" . my-latex-insert-img-at-copied-url))
     #+END_SRC


*** Org
    I am consider that Org Mode built in Emacs:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package org
          :major-mode-map (org-mode)
          :bind
          ((:map xah-fly-command-map)
           ("1"   . 'my-er-expand-region-or-org-todo)
           (:map my-org-local-map)
           ("SPC" . 'org-toggle-checkbox)
           ("'"   . 'org-edit-special)
           ("l"   . 'org-insert-link)
           ("t"   . 'org-babel-tangle)
           ("p"   . 'org-latex-preview)
           ("1"   . 'org-todo)
           ("s"   . 'org-schedule)
           ("RET" . 'org-open-at-point)))

      (defvar my-last-command-is-org-todo nil
        "To t, when last `my-er-expand-region-or-org-todo' done `org-todo'.")

      (defun my-er-expand-region-or-org-todo ()
        "If need do `org-todo', otherwise do `er/expand-region'."
        (interactive)
        (let ((is-org-todo (or
                             (eq last-command #'org-todo)
                             (and
                              (eq last-command this-command)
                              my-last-command-is-org-todo))))
          (setq my-last-command-is-org-todo is-org-todo)
          (if is-org-todo
              (call-interactively #'org-todo)
            (call-interactively #'er/expand-region))))

    #+END_SRC

**** Centering Org
     I am centering text, when enable =org-mode=:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (add-hook 'org-mode-hook (lambda () (call-interactively 'visual-fill)))

     #+END_SRC

**** Auto Format in Org
     I am use my autoformat system, which I am taked from [[https://github.com/jkitchin/scimax/][scimax]]:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (my-use-all-autoformat-in-mode 'org-mode)

     #+END_SRC

**** Load from Wiki
     I am use [[https://github.com/progfolio/wikinforg][wikinforg]]:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package wikinforg
           :ensure t)

     #+END_SRC

**** Drag and Drop Images to Org
     I am use [[https://github.com/abo-abo/org-download][org-download]] for this:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package org-download
           :ensure t
           :hook
           (dired-mode-hook . org-download-enable))

     #+END_SRC

**** Navigation beetween Org Headings in Current Buffer
     I am use [[https://github.com/emacs-helm/helm-org][helm-org]] for navigation in Org Mode:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package helm-org
           :ensure t
           :bind (:map org-mode-map
                       ([remap helm-imenu]
                        . helm-org-in-buffer-headings)))

     #+END_SRC

**** Improvement Navigation beetween Org Headings
     I am use [[https://github.com/alphapapa/org-ql][org-ql]] for smart queries to find my =org= Files:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package org-ql
           :ensure t
           :config
           (require 'org-ql))

       (use-package helm-org-ql
           :ensure t
           :config
           (global-set-key (kbd "S-<f9>") 'my-view-todos))

       (defun my-view-todos ()
         "View my todos."
         (interactive)
         (org-ql-search
             (my-all-buffers-with-ext "org")
             "todo:TODO"
             :super-groups '((:auto-parent))))

       (defun fast-exec-org-ql-keys ()
         "Get some useful keymaps of  `fast-exec' for org-ql."
         (fast-exec/some-commands
          ("Search Org Files via Org Query Language" 'org-ql-search)))

       (fast-exec/register-keymap-func 'fast-exec-org-ql-keys)
       (fast-exec/reload-functions-chain)

     #+END_SRC

**** Paste Link from Browser
     I'm use [[https://github.com/rexim/org-cliplink][org-cliplink]] from cool man [[https://github.com/rexim/org-cliplink][Alexey Kutepov]].  Because I
     install this package I can copy any link from web-browser, run
     commnad =org-cliplink= (I'm bind to =SPC l i=) and my clipboard
     will have a org code to copied link

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package org-cliplink
           :ensure t
           :bind
           ((:map my-org-local-map)
            ("i" . org-cliplink)))

     #+END_SRC

**** Generate Table of Contents in Org
     I am use [[https://github.com/snosov1/toc-org][toc-org]].  This cool package helps you to have an
     up-to-date table of contents in org files.  I just add tag :TOC:
     to any org heading and after save this file table of contents
     will automatically updated

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package toc-org
           :ensure t
           :hook (org-mode . toc-org-mode)
           :custom
           (toc-org-max-depth 4))

     #+END_SRC

**** Org + CDLaTeX
     In =LaTeX= for navigation and first insertion of commands I am
     use [[https://github.com/cdominik/cdlatex][CDLaTeX]], In =org= I must use it too:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (defun turn-on-org-cdlatex-mode ()
         "Turn on `org-cdlatex-mode'."
         (interactive)
         (org-cdlatex-mode t))

       (add-hook 'org-mode-hook #'turn-on-org-cdlatex-mode)

     #+END_SRC


*** Elisp
**** Special Linters
***** Package Linter
      I am use [[https://github.com/purcell/package-lint][package-lint]] for lint my packages for Melpa for view I
      am use [[https://github.com/purcell/flycheck-package][flycheck-package]]:

      #+BEGIN_SRC emacs-lisp :tangle ~/init.el

        (use-package package-lint
            :ensure t)

        (use-package flycheck-package
            :ensure t
            :init
            (flycheck-package-setup))

       #+END_SRC

**** Refactoring
     I am use [[https://github.com/Wilfred/emacs-refactor][emacs-refactor]] for refactor not only in =emacs-lisp=:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package emr
           :ensure t
           :bind (:map xah-fly-command-map
                       ("SPC /" . emr-show-refactor-menu)))
                       #+END_SRC

**** Package Manager
     I am use [[https://github.com/cask/cask/][Cask]] for manage packages of =elisp=:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package cask-mode
           :ensure t
           )

           #+END_SRC

**** Elisp Format Code
     I am use [[https://github.com/riscy/elfmt][elfmt]] of =Riscky=:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el
       (use-package elfmt
           :config
         (elfmt-global-mode 1))

         #+END_SRC

**** Modern Documentation
     I am use [[https://github.com/Wilfred/suggest.el][suggest]], I am just type print input and excepted output and see suggesting examples as this do:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package suggest
           :ensure t
           )

           #+END_SRC

**** Elisp Docstrings Mode
     I am use [[https://github.com/Fuco1/elisp-docstring-mode][elisp-docstring-mode]] with [[https://github.com/Fuco1/elisp-docstring-mode][string-edit]]:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (defun my-edit-elisp-docstring ()
         "Edit `elisp' docstring via `string-edit' and `elisp-docstring-mode'."
         (interactive)
         (string-edit-at-point)
         (elisp-docstring-mode))

       (use-package elisp-docstring-mode
           :ensure t
           :bind (:map emacs-lisp-mode-map
                       ([remap string-edit-at-point] . my-edit-elisp-docstring)))

                       #+END_SRC

**** Elisp Indent Code
     I am use standard functions of indenting lisp code, but some
     variables set to non normal values:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el
       (setq lisp-body-indent 2)
       #+END_SRC

**** Some Insertion Functions for Elisp
     In =org-mode= I am press =M-RET= for insertion heading, in
     =elisp= I need to press =M-RET= for insetion of class' fields
     (see [[info:EIEIO][Info about Classes in Elisp]]):

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el
       ;;

       (defun my-goto-defclass-beg ()
         "Goto backward defclass."
         (search-backward-regexp "(\\W*defclass" nil t)
         (skip-chars-forward "("))

       (defun my-goto-fields-defclass-defnition ()
         "Go to fields of `defclass' defnition."
         (interactive)
         (my-goto-defclass-beg)
         (forward-sexp 4)
         (forward-char -1)
         (-when-let (sexp (sp-get-enclosing-sexp))
           (sp-get sexp (goto-char :end-in))))

       (defun my-elisp-in-defclass-p (&optional pt)
         "Move to PT and return name of function/macros in which stay this sexp."
         (setq pt (or pt (point)))
         (save-excursion
           (goto-char pt)
           (when (my-goto-defclass-beg)
             (-when-let (sexp (sp-get-enclosing-sexp))
               (sp-get sexp (< :beg pt :end))))))

       (defun my-elisp-defclass-name ()
         "Return name of `defclass' defnition."
         (interactive)
         (save-excursion
           (my-goto-defclass-beg)
           (forward-sexp 1)
           (forward-char 1)
           (sexp-at-point)))

       (defun my-elisp-new-field-of-class ()
         "Insert new field of Lisp class.
       Only when in class defnition."
         (interactive)
         (when (my-elisp-in-defclass-p)
           (my-goto-fields-defclass-defnition)
           (unless (my-current-line-is-empty-p)
             (newline-and-indent))
           (yas-expand-snippet
            (format "(${1:name} :initarg :$1 :accessor %s-$1)"
                    (my-elisp-defclass-name)))))

       (define-key emacs-lisp-mode-map (kbd "M-RET") 'my-elisp-new-field-of-class)

     #+END_SRC

# **** Auto format in Elisp
#      I am use [[*Functions for Auto Format Code][My own system for Autoformat inspired from Scimax]].  When
#      I start elisp docstring first letter will automatically
#      capitalizated

#      #+BEGIN_SRC emacs-lisp :tangle ~/init.el

#        (defun autoformat-elsip-docstring-capitalization ()
#          "If last symbol is start of Elisp docstring, capitalize its."
#          (interactive)
#          (and
#           (in-string-p)
#           (not (forward-char -1))
#           (looking-back "\"")
#           (progn
#             (forward-char -1)
#             (ignore-errors (backward-sexp 3))
#             t)
#           (looking-at-p
#            (regexp-opt '("defun" "defmacro"
#                          "cl-defun" "cl-defmacro"
#                          "defun*" "defmacro*"
#                          "lambda" "-lambda")))
#           (capitalize-word -1)))

#        (my-use-autoformat-in-mode 'emacs-lisp-mode elsip-docstring-capitalization)
#      #+END_SRC


*** Markdown
    I am use [[https://github.com/jrblevin/markdown-mode/][markdown-mode]] , and for its I am centering code:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package markdown-mode
          :ensure t
          :major-mode-map t
          :bind (:map
                 my-markdown-mode-local-map
                 ("<SPC>"     . markdown-toggle-gfm-checkbox)
                 ("b"     . markdown-insert-bold)
                 ("i"     . markdown-insert-italic)
                 ("l"     . markdown-insert-link)
                 ("p"     . markdown-live-preview-mode)
                 ("'"     . markdown-edit-code-block)
                 ("<RET>" . markdown-follow-thing-at-point))
          :hook (markdown-mode . visual-fill)
          :init
          (setq markdown-imenu-generic-expression
                '(("title""^\\(.*\\)[\n]=+$" 1)
                  ("h2-"  "^\\(.*\\)[\n]-+$" 1)
                  ("h1"   "^# \\(.*\\)$" 1)
                  ("h2"   "^## \\(.*\\)$" 1)
                  ("h3"   "^### \\(.*\\)$" 1)
                  ("h4"   "^#### \\(.*\\)$" 1)
                  ("h5"   "^##### \\(.*\\)$" 1)
                  ("h6"   "^###### \\(.*\\)$" 1)
                  ("fn"   "^\\[\\^\\(.*\\)\\]" 1)))

          (add-hook 'markdown-mode-hook
                    (lambda ()
                      (setq-local imenu-generic-expression
                                  markdown-imenu-generic-expression))))

    #+END_SRC

**** Create Table of Contents in Markdown
     I am use [[https://github.com/ardumont/markdown-toc][markdown-toc]]:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package markdown-toc
           :ensure t
           :bind (:map
                  my-markdown-mode-local-map
                  ("t" . 'markdown-toc-generate-or-refresh-toc)))

                  #+END_SRC

**** Auto Format in markdown
     I am use my own [[*Functions for Auto Format Code]] to auto format in
     =markdown=:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (my-use-all-autoformat-in-mode 'markdown-mode)
       (my-use-all-autoformat-in-mode 'gfm-mode)

     #+END_SRC

*** Python
**** Vars
     Var =py/imports-regexp= is regexp of import statements in python:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (setq py/imports-regexp "import\\|from")

       #+END_SRC

     Var =python-shell-interpreter= is builtin Emacs var, see docs in Emacs:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (setq python-shell-interpreter "python")

       #+END_SRC

**** Navigation

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (defun py-nav-to-imports ()
         "Navigate to imports in Python mode."
         (interactive)
         (push-mark)
         (let ((old-pos (point)))
           (goto-char (point-min))
           (search-forward-regexp py/imports-regexp old-pos old-pos))
         )

       (add-nav-to-imports-for-language
        python-mode
        py-nav-to-imports)

        #+END_SRC

**** Linters

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (setq flycheck-python-flake8-command "python -m flake8")
       (setq flycheck-python-mypy-executable "python -m mypy")
       (setq flycheck-python-pylint-executable "python -m pylint")

       #+END_SRC

**** Helping info
     I am use [[https://www.emacswiki.org/emacs/pydoc-info.el][pydoc-info]]:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package pydoc
           :ensure t)

           #+END_SRC

**** Autocomplete
     I am hasn't autocompletion special for python, so I enable default =dabbrev-autocompletion=:
     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (defun enable-dabbrev-company-backend ()
         "Add `company-dabbrev' backend to `company-backends' for local major mode."
         (interactive)
         (setq-local company-backends (cons 'company-dabbrev company-backends))
         )

       (add-hook 'python-mode-hook 'enable-dabbrev-company-backend)

       #+END_SRC

*** Rust
**** Auto Completion in Rust
     I am use [[https://github.com/racer-rust/emacs-racer][racer]]:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package racer
           :ensure t
           :hook ((rust-mode  . racer-mode)
                  (racer-mode . eldoc-mode)))

                  #+END_SRC
**** Check Errors
     I am use [[https://github.com/flycheck/flycheck-rust][flycheck-rust]]:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package flycheck-rust
           :ensure t
           :config
           (flycheck-rust-setup))

           #+END_SRC

*** Go Lang
    I am use [[https://github.com/dominikh/go-mode.el][go-mode]]:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package go-mode
          :ensure t)

      (use-package go-eldoc
          :ensure t
          :hook (go-mode-hook . 'go-eldoc-setup))

          #+END_SRC

**** Add Import

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (add-import-keymap-for-language go-mode
                                       go-import-add)

                                       #+END_SRC

*** PDF
    I am use [[https://github.com/vedang/pdf-tools][pdf-tools]]:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package pdf-tools
          :ensure t
          )

          #+END_SRC

*** Haskell
    I am use [[https://github.com/haskell/haskell-mode][haskell-mode]], and I love =indention-mode=:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package haskell-mode
          :ensure t
          :hook (haskell-mode . haskell-indent-mode))

      (add-import-keymap-for-language
       haskell-mode
       haskell-add-import)

      (add-nav-to-imports-for-language
       haskell-mode
       haskell-navigate-imports)

       #+END_SRC
**** Auto Completion for Haskell
     I am use [[https://github.com/horellana/company-ghci][company-ghci]]:
     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package company-ghci
           :ensure t
           :init
           (push 'company-ghci company-backends)
           (add-hook 'haskell-mode-hook 'company-mode)
           (add-hook 'haskell-interactive-mode-hook 'company-mode))

           #+END_SRC

*** JavaScript (Node.js)
**** Variables
     Variable `js/imports-regexp` if regular expression for search imports in JS.
     Defaults to:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (setq js/imports-regexp "import")

       #+END_SRC

     Variable `js/function-or-class-regexp` if regular expression for search imports in JS.
     Defaults to:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (setq js/function-or-class-regexp "function \\|class ")

       #+END_SRC

**** Repl
     I am use [[https://github.com/redguardtoo/js-comint][js-comint]] for run my JS' code:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package js-comint
           :ensure t)

       (if (user-os-windows-p)
           (setq js-comint-program-command "C:/Program Files/nodejs/node.exe"))

           #+END_SRC

**** Linters
     I am use some packages which you can see on [[http://codewinds.com/blog/2015-04-02-emacs-flycheck-eslint-jsx.html#summary][this]] page:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package web-mode
           :ensure t)

       (defun my-enable-flycheck ()
         (flycheck-mode 1))

       (use-package js2-mode
           :ensure t
           :mode "\\.js$"
           :custom
           (js2-allow-rhino-new-expr-initializer nil)
           (js2-auto-indent-p nil)
           (js2-enter-indents-newline nil)
           (js2-global-externs '("module"
                                 "require"
                                 "buster"
                                 "sinon"
                                 "assert"
                                 "refute"
                                 "setTimeout"
                                 "clearTimeout"
                                 "setInterval"
                                 "clearInterval"
                                 "location"
                                 "__dirname"
                                 "console"
                                 "JSON"))
           (js2-idle-timer-delay 0.1)
           (js2-indent-on-enter-key nil)
           (js2-mirror-mode nil)
           (js2-strict-inconsistent-return-warning nil)
           (js2-auto-indent-p t)
           (js2-include-rhino-externs nil)
           (js2-include-gears-externs nil)
           (js2-concat-multiline-strings 'eol)
           (js2-rebind-eol-bol-keys nil)
           (js2-show-parse-errors nil)
           (js2-strict-missing-semi-warning nil)
           (js2-strict-trailing-comma-warning t)
           :hook (js2-mode . my-enable-flycheck))

           #+END_SRC

**** Navigation

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (defun js/nav-to-imports ()
         "Navigate to imports in JS mode."
         (interactive)
         (push-mark)
         (let ((old-pos (point)))
           (goto-char (point-min))
           (search-forward-regexp js/imports-regexp old-pos old-pos))
         )

       (add-nav-to-imports-for-language
        js2-mode
        js/nav-to-imports)

        #+END_SRC

*** JSON
    I am use [[https://github.com/Sterlingg/json-snatcher][json-snatcher]] for copy JSON "path" to current node:
    For this I am press =SPC l c=:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package json-mode
          :major-mode-map t)

      (use-package json-snatcher
          :ensure t
          :bind
          (:map
           my-json-mode-local-map
           ("c" . jsons-print-path)))

           #+END_SRC

    #+RESULTS:
    : my-json-setup

*** HTML
**** Variables
     Variable =html-modes= is list of modes which is for =html=:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (defcustom html-modes '(web-mode html-mode mhtml-mode)
         "List of `html` major modes.")

         #+END_SRC

**** Web Mode
     I am use [[https://web-mode.org][web-mode]] and [[https://github.com/smihica/emmet-mode][emmet]] and [[https://github.com/jcs-elpa/auto-rename-tag][auto-rename-tag]]:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el
       (use-package web-mode
           :ensure t
           :hook (web-mode . yas-minor-mode-off)
           :custom
           (web-mode-script-padding 1)
           (web-mode-block-padding 0))
           #+END_SRC

**** Auto Rename Tag
     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package auto-rename-tag
           :ensure t
           :config
           :init
           (--each html-modes
             (add-hook (intern (s-append "-hook" (symbol-name it)))
                       (lambda () (auto-rename-tag-mode 38)))))

                       #+END_SRC

**** Emmet

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package emmet-mode
           :ensure t
           :custom (emmet-move-cursor-between-quotes t)
           :hook
           (web-mode . emmet-mode)
           (mhtml-mode . emmet-mode)
           (css-mode . emmet-mode)
           (html-mode . emmet-mode))

       (use-package helm-emmet
           :ensure t
           :init
           (defun fast-exec-helm-emmet-keys ()
             "Keymaps for `helm-emmet'."
             (fast-exec/some-commands
              ("View Emmet Cheat" 'helm-emmet)))
           (fast-exec/register-keymap-func 'fast-exec-helm-emmet-keys)
           (fast-exec/reload-functions-chain))

           #+END_SRC

**** =Paredit= for HTML
     I am use [[https://github.com/magnars/tagedit][tagedit]] of =magnars=:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el
       (use-package tagedit
           :ensure t
           :init
           (--each html-modes
             (let ((map-symbol (intern (s-append "-map" (symbol-name it))))
                   map)
               (when (boundp map-symbol)
                 (setq map (eval map-symbol))
                 (define-key
                     map
                     [remap sp-kill-hybrid-sexp]
                   'tagedit-kill)
                 (define-key
                     map
                     [remap sp-join-sexp]
                   'tagedit-join-tags)
                 (define-key
                     map
                     [remap sp-raise-sexp]
                   'tagedit-raise-tag)
                 (define-key
                     map
                     [remap sp-splice-sexp]
                   'tagedit-splice-tag)
                 (define-key
                     map
                     [remap sp-change-enclosing]
                   'tagedit-kill-attribute)))))

                   #+END_SRC

**** Auto Complete for HTML
     I am use [[https://github.com/osv/company-web][company-web]]:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package company-web
           :ensure t
           :init
           (add-hook 'web-mode-hook
                     (lambda ()
                       (set (make-local-variable 'company-backends)
                            '(company-web-html))
                       (company-mode t))))

                       #+END_SRC

*** CSS
    I am use =web-mode= and builtin =css-mode=:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package css-mode)

      #+END_SRC

**** Fly Documentation
     I am use =css-eldoc= from =Elpa=:

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (use-package css-eldoc
           :ensure t
           :init
           (dolist (hook (list 'web-mode-hook 'css-mode-hook))
             (add-hook hook 'css-eldoc-enable)))

             #+END_SRC
* Support of Some Special Modes
** Calc
   I am use built-in emacs =calc=, I disable =xah-fly-keys= when run
   calc:

   #+BEGIN_SRC emacs-lisp :tangle no

     (add-hook 'after-change-major-mode-hook
               (lambda ()
                 (when (eq major-mode 'calc-mode)
                   (calc-mode))))

   #+END_SRC

* Small Organize Tricks
** Very Small Tricks

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (show-paren-mode 2)
     (setq make-backup-files         nil)
     (setq auto-save-list-file-name  nil)
     (defalias 'yes-or-no-p 'y-or-n-p)
     (toggle-truncate-lines 38)

     #+END_SRC
** Highlight Git Changes
   I am use [[https://github.com/emacsorphanage/git-gutter][git-gutter]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package git-gutter
         :ensure t
         :hook
         (prog-mode . git-gutter-mode))

         #+END_SRC
** Helpful
*** Which Key?

    I am use [[https://github.com/justbur/emacs-which-key][which-key]]:

    #+BEGIN_SRC emacs-lisp  :tangle  ~/init.el
      (use-package which-key
          :ensure t
          :config
          (which-key-setup-side-window-bottom)
          (which-key-mode))
    #+END_SRC

*** Helpful Package
    I am use [[https://github.com/Wilfred/helpful][helpful]], for pretty help info about lisp functions and major modes:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package helpful
          :ensure t
          :init
          (global-set-key (kbd "C-h f") #'helpful-callable)
          (global-set-key (kbd "C-h v") #'helpful-variable)
          (global-set-key (kbd "C-h k") #'helpful-key)
          (global-set-key (kbd "C-c C-d") #'helpful-at-point)
          (global-set-key (kbd "C-h F") #'helpful-function)
          (global-set-key (kbd "C-h C") #'helpful-command))

    #+END_SRC

** Autocompletion of Commands (HELM)
   I am use [[https://github.com/emacs-helm/helm][HELM]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package helm
         :ensure t
         :custom
         (helm-M-x-fuzzy-match        t)
         (helm-buffers-fuzzy-matching t)
         (helm-recentf-fuzzy-match    t)
         (helm-imenu-fuzzy-match      t)
         (helm-autoresize-min-height 20)
         (helm-left-margin-width 2)
         (helm-buffers-left-margin-width 2)
         :init
         (helm-autoresize-mode +1)
         (helm-mode +1)
         :bind (("C-h a"     . 'helm-apropos)
                (:map xah-fly-command-map)
                ("SPC SPC f" . 'helm-find-files)
                ("SPC k r"   . 'helm-regexp)))

                #+END_SRC

** Command Log
   I am use [[https://github.com/lewang/command-log-mode][command-log-mode]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package command-log-mode
         :ensure t)

   #+END_SRC
   
** Whitespaces Mode
   I am enable whitespaces mode on =prog-mode=:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (add-hook 'prog-mode-hook 'whitespace-mode)

     #+END_SRC

** Visual Fill Line Mode
   I am ussally use =visual-fill-line-mode=:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (add-hook 'change-major-mode-hook 'visual-line-mode)

     #+END_SRC

** Auto Fill Paragraphs
   I am enable [[https://github.com/davidshepherd7/aggressive-fill-paragraph-mode/][aggressive-fill-paragraph-mode]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package aggressive-fill-paragraph
         :ensure t
         :config
         (afp-setup-recommended-hooks))

   #+END_SRC

** Scratches
   I am press =C-t= for opening scratch for this I am use [[https://github.com/ieure/scratch-el][scratch-el]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package scratch
         :ensure t
         :bind (("C-t" . scratch)))

   #+END_SRC

** Syntax Subword Mode
   I am use [[https://melpa.org/#/syntax-subword][syntax-subword]], for example if I am in current situation:

   #+BEGIN_SRC shell
     \|print(name)
   #+END_SRC

   And i am need to delete indent, I am just delete its when delete backward word:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package syntax-subword
         :ensure t
         :custom
         (syntax-subword-skip-spaces t)
         :config
         (global-syntax-subword-mode))

    #+END_SRC

** Small Pandoc Functions
   I have function =my-pandoc-tex-to-documents-dir=, which do what
   name say:
   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defun my-pandoc-tex-to-documents-dir ()
       "Move all .docx files in working dir to directroy documents."
       (f-mkdir "documents")
       (-->
        (file-expand-wildcards "*.tex")
        (-map 'f-base it)
        (--each
            it
          (shell-command
           (s-lex-format
            "pandoc -t docx -f latex -o documents/${it}.docx ${it}.tex")))))

     (defun fast-exec-pandoc-keys ()
       "Get some useful keymaps of  `fast-exec' for pandoc"
       (fast-exec/some-commands
        ("Convert Tex Files and Move to Documents Dir"
         'my-pandoc-tex-to-documents-dir)))

     (fast-exec/register-keymap-func 'fast-exec-pandoc-keys)
     (fast-exec/reload-functions-chain)

     #+END_SRC

** I am Russian!
   I am russian man, and I must use russian keyboard with `english`
   hot keys, so I am use builtin emacs =input-method=:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (setq default-input-method "russian-computer")

     #+END_SRC

** Disable or Enable Modes
   I am use [[https://github.com/istib/helm-mode-manager][helm-mode-manager]], which has functions
   =helm-switch-major-mode= =helm-enable-minor-mode= and
   =helm-disable-minor-mode=, I bound that via =fast-exec=

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package helm-mode-manager
         :ensure t
         :config
         (defun fast-exec-helm-mode-manager-keys ()
           "Get some useful keymaps of  `fast-exec' for helm-mode-manager."
           (fast-exec/some-commands
            ("Switch Major Mode" 'helm-switch-major-mode)
            ("Enable Minor Mode" 'helm-enable-minor-mode)
            ("Disable Minor Mode" 'helm-disable-minor-mode)))

         (fast-exec/register-keymap-func 'fast-exec-helm-mode-manager-keys)
         (fast-exec/reload-functions-chain))

   #+END_SRC

** Cow Say
   I am use [[https://github.com/lassik/emacs-cowsay][very serious cowsay]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package cowsay
         :ensure t
         :custom
         (cowsay-directories '("~/.emacs.d/cows"))
         :config
         (cowsay-load-cows)
         (defun fast-exec-define-cowsay-keymaps ()
           "Some useful keymaps for `cowsay'/`fast-exec'."
           (fast-exec/some-commands
            ("Cow Say String..."  'cowsay-string)
            ("Cow Say Region..."  'cowsay-region)
            ("Cow Say and Insert" 'cowsay-replace-region)
            ("Cow Say Load Cows"  'cowsay-load-cows)))
         (fast-exec/register-keymap-func 'fast-exec-define-cowsay-keymaps)
         (fast-exec/reload-functions-chain))

         #+END_SRC

** Auto Save
   I am use [[https://github.com/bbatsov/super-save][super-save]]:
   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (add-to-list 'load-path "~/projects/super-save/")

     (use-package super-save
         :config
       (setq super-save-exclude '("Emacs.org"))
       (setq auto-save-default nil)
       (super-save-mode 38))

       #+END_SRC

** Read Documentation for Developers
   I am use [[https://github.com/astoff/devdocs.el][devdocs]] for see documentation from [[https://devdocs.io][DevDocs]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package devdocs
         :ensure t
         :hook (python-mode . (lambda ()
                                (setq-local devdocs-current-docs
                                            '("python~3.9"))))
         )

         #+END_SRC

** Pomidor
   For pomidor I am use [[https://github.com/TatriX/pomidor][pomidor]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package pomidor
         :ensure t
         :bind (("<f12>" . pomidor))
         :custom
         (pomidor-sound-tick . nil)
         (pomidor-sound-tack . nil)
         :hook
         (pomidor-mode . (lambda ()
                           (display-line-numbers-mode -1)
                           (setq left-fringe-width 0 right-fringe-width 0)
                           (setq left-margin-width 2 right-margin-width 0)
                           (set-window-buffer nil (current-buffer))))
         :init
         (pomidor))

                           #+END_SRC

** Pacman
   I am use [[https://github.com/semenInRussia?tab=stars][pacmacs]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package pacmacs
         :ensure t
         :init
         (defun fast-exec-define-pacmacs-keys ()
           "Bind `fast-exec' and `pacmacs'."
           (fast-exec/some-commands
            ("Play to Pacmacs" 'pacmacs-start))
           )
         (fast-exec/register-keymap-func 'fast-exec-define-pacmacs-keys)
         (fast-exec/reload-functions-chain))

         #+END_SRC

** Wikipedia
   I am use [[https://github.com/emacs-helm/helm-wikipedia][helm-wikipedia]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package helm-wikipedia
         :ensure t)

         #+END_SRC

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package helm-spotify-plus
         :ensure t)

         #+END_SRC

** View Github Stars
   I am use [[https://github.com/Sliim/helm-github-stars][helm-github-stars]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package helm-github-stars
         :ensure t
         :custom
         (helm-github-stars-username "semeninrussia")
         :init
         (defun fast-exec-define-helm-github-stars ()
           "Bind `helm-github-stars' and `fast-exec'."
           (fast-exec/some-commands
            ("View Github Stars" 'helm-github-stars-fetch)))
         (fast-exec/register-keymap-func 'fast-exec-define-helm-github-stars)
         (fast-exec/reload-functions-chain))

         #+END_SRC

** Easy Generate .gitignore
   I am use [[https://github.com/jupl/helm-gitignore][helm-gitignore]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     ;; (use-package helm-gitignore
     ;;     :ensure t
     ;;     :init
     ;;     (defun fast-exec-define-helm-gitignore-keys ()
     ;;         "Bind `fast-exec' and `helm-gitignore'."
     ;;         (fast-exec/some-commands
     ;;          ("Generate Gitignore" 'helm-gitignore)))
     ;;     (fast-exec/register-keymap-func 'fast-exec-define-helm-gitignore-keys)
     ;;     (fast-exec/reload-functions-chain)))

     #+END_SRC

** Google
   I am use built-in =helm= command =helm-google-suggest=, this
   command takes some suggestions from the Google, but query may be
   done in other search engine (for example Wikipedia)

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defun fast-exec-helm-net-define-keys ()
       "Keymaps for `helm-net' and `fast-exec'."
       (fast-exec/some-commands
        ("Search via Google" 'helm-google-suggest)))

     (fast-exec/register-keymap-func 'fast-exec-helm-net-define-keys)
     (fast-exec/reload-functions-chain)

   #+END_SRC

** Kinopoisk
   I am use [[https://github.com/semenInRussia/emacs-kinopoisk][emacs-kinopoisk]] for management of Films:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package helm-kinopoisk
         :load-path "~/projects/emacs-kinopoisk")

   #+END_SRC

** Make Broken PPTX File
   I need to fast make fake and broken PPTX file, so I just make for
   this Function:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defun my-new-fake-pptx-file ()
       "Make this buffer, fake presentation with format (.pptx)."
       (interactive)
       (->> "~/broken.pptx" (f-read) (insert))
       (text-mode))

     (defun fast-exec-fake-pptx-keys ()
       "Get some useful keymaps of  `fast-exec' for fake-pptx."
       (fast-exec/some-commands ("New Fake PPTX File" 'my-new-fake-pptx-file)))

     (fast-exec/register-keymap-func 'fast-exec-fake-pptx-keys)
     (fast-exec/reload-functions-chain)

   #+END_SRC

** Films Management
   I very love see a lot of films, but I forgot films' names every
   day, so I create most simple management of films.  I have snippet
   =film=, which add film to current =org= file, which be films'
   management database and command =my-films-list= which show saved
   films

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defun my-films-add (film)
       "Add FILM to current org file, this file is db of films."
       (interactive (list (my-films--search-new)))
       (org-meta-return)
       (insert "MUST-SEE ")
       (insert (kinopoisk-film-original-name film))
       (my-org-set-props
        (name      . (kinopoisk-film-name film))
        (year      . (kinopoisk-film-year film))
        (slogan    . (kinopoisk-film-slogan film))
        (id        . (kinopoisk-film-id film))
        (rating    . (kinopoisk-film-rating film))
        (countries . (kinopoisk-film-countries film))))

     (defmacro my-org-set-props (&rest key-and-val)
       "Set properties of org heading with keys from KEY-AND-VAL and values from it."
       (->>
        key-and-val
        (--map
         `(org-set-property ,(symbol-name (car it)) (format "%s" ,(cdr it))))
        (cons 'progn)))

     (defun my-films--search-new ()
       "Search film from the Internet."
       ;; I know that instead of `flet', I can use `cl-flet', but `cl-flet'
       ;; redefine funcitons only in body
       (flet
           ((helm-kinopoisk--handle-film (film) film))
         (helm-kinopoisk-search-films)))

     (defun my-films--choose-from-top ()
       "Choose one film from the Kinopoisk top."
       ;; I know that instead of `flet', I can use `cl-flet', but `cl-flet'
       ;; redefine funcitons only in body
       (flet
           ((helm-kinopoisk--handle-film (film) film))
         (call-interactively #'helm-kinopoisk-see-films-top)))

     (defun my-films-list ()
       "List of films saved in films management file."
       (interactive)
       (helm
        :buffer "*saved-films*"
        :sources
        '((name       . "List of Saved Films")
          (candidates . my-films--list-candidates)
          (action     . helm-kinonpoisk-search-source))))

     (defun my-films--list-candidates ()
       "Helm candidates for `my-films-list'."
       (->>
        (org-ql-query
          :from (my-all-buffers-with-ext "org")
          :where '(todo "MUST-SEE")
          :select #'my-films--from-org-heading)
        (--map
         (cons (helm-kinopoisk--format-film-for-display it) it))))

     (defun my-films--from-org-heading ()
       "Parse org heading at current position to `kinopoisk-film'."
       (when (my-current-line-prefix-p "*")
         (kinopoisk-film
          :id (car (string-to-number (org-property-values "id")))
          :year (car (org-property-values "year"))
          :name (car (org-property-values "name")))))


   #+END_SRC

   #+RESULTS:
   : 1

** See Recent Files
   I am use built in Emacs =recentf-mode= and keymap =SPC k f= for
   view recentf files, as =SPC f= but add =k=:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package recentf
         :config (recentf-mode 69) ; Lol!
         :bind ((:map xah-fly-command-map)
                ("SPC k f" . 'recentf-open-files))
         :hook ((recentf-dialog-mode) . 'xah-fly-insert-mode-activate))

   #+END_SRC

** Take Color or Face
   I am use built-in helm command =helm-color=. (see [[http://tuhdo.github.io/helm-intro.html][this article]])

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defun fast-exec-helm-colors-keys ()
       "Get some useful keymaps of  `fast-exec' for helm-colors."
       (fast-exec/some-commands ("Get Color" 'helm-colors)))

     (fast-exec/register-keymap-func 'fast-exec-helm-colors-keys)
     (fast-exec/reload-functions-chain)

   #+END_SRC

* Graphic User Interface
** Hide ALL
   This is standard stuf

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode   -1)

     (add-to-list 'default-frame-alist '(fullscreen . maximized))
     (add-hook 'emacs-startup-hook 'toggle-frame-fullscreen)

     #+END_SRC

** Color Themes
   I am use some themes, depends on my state.

*** Gruber Darker Theme

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package gruber-darker-theme
         :ensure t)

   #+END_SRC

*** Some Proffesional Themes
    I am use [[https://github.com/doomemacs/themes][doom-themes]]:
    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package doom-themes
          :ensure t)

    #+END_SRC

*** Some other themes
    Also I am use black theme of =magnars=:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (add-to-list 'custom-theme-load-path
                   "~/.emacs.d/themes")

    #+END_SRC

*** Load Theme
    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (load-theme 'doom-monokai-classic t)

    #+END_SRC

** Numbers of lines
*** Vars
    Var `dont-display-lines-mode` is list of modes,
    for this modes willn't display numbers of lines. Defaults to:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (setq dont-display-lines-modes
            '(org-mode
              term-mode
              shell-mode
              treemacs-mode
              eshell-mode
              helm-mode))

              #+END_SRC

*** Enable and Disable
    I am display numbers of lines in each mode, excluding modes from
    `dont-display-lines-mode` list:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el
      (defun display-or-not-display-numbers-of-lines ()
        "Display numbers of lines OR don't display numbers of lines.
      If current `major-mode` need to display numbers of lines, then display
      numbers of lines, otherwise don't display."
        (interactive)
        (if (-contains? dont-display-lines-modes major-mode)
            (display-line-numbers-mode 0)
          (display-line-numbers-mode 38))
        )

      (add-hook 'prog-mode-hook 'display-or-not-display-numbers-of-lines)
      #+END_SRC

** Modeline
   I am use [[https://github.com/seagle0128/doom-modeline][doom-modeline]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package doom-modeline :ensure t)

   #+END_SRC

*** Modeline for =drag=
    I need to see when keys will readed as =drag=:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (doom-modeline-def-segment drag
        (when (my-last-command-is-dragged-stuff-p)
          (propertize
           " DRG "
           'face (if (doom-modeline--active)
                     'doom-modeline-panel
                   'mode-line-inactive))))

    #+END_SRC

*** Disable View of =xah-fly-keys= State

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el
      (doom-modeline-def-segment my-matches
        "Display `macro-recoring', `multiple-cursors' and `buffer-size'."
        (let ((meta (concat (doom-modeline--macro-recording)
                            (doom-modeline--multiple-cursors))))
          (or (and (not (equal meta "")) meta)
              (doom-modeline--buffer-size))))
    #+END_SRC

*** Watch Time in Doom-Modeline

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (defcustom my-modeline-time-segment-format-string " [%H-%M]"
        "By this format string will draw time in `doom-modeline'.
      See `format-time-string' for see what format string"
        :type 'string)

      (doom-modeline-def-segment time
          (let* ((hour (string-to-number (format-time-string "%H"))))
            (propertize
             (format-time-string my-modeline-time-segment-format-string)
             'face
             (if (< 4 hour 19)
                 'hi-red-b
               'outline-1))))

               #+END_SRC
*** Pomidor in Modeline
    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (doom-modeline-def-segment pomidor
          ()
        "Return header."
        (when (featurep 'pomidor)
          (let* ((state (pomidor--current-state))
                 (break (pomidor--break-duration state))
                 (overwork (pomidor--overwork-duration state))
                 (work (pomidor--work-duration state))
                 (face (cond
                         (break 'pomidor-break-face)
                         (overwork 'pomidor-overwork-face)
                         (work 'pomidor-work-face)))
                 (pomidor-time-format " Pom %-Mm")
                 (time (-first 'identity (list break overwork work))))
            (propertize (pomidor--format-time time) 'face face))))

            #+END_SRC

*** Truncate Buffer's Name in Modeline

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (defvar durand-buffer-name-max 20
        "The maximal length of the buffer name in modeline.")

      (doom-modeline-def-segment buffer-info-durand
          ()
        (declare (pure t) (side-effect-free t))
        (let* ((buffer-info
                (format-mode-line
                 (s-truncate
                  durand-buffer-name-max
                  (doom-modeline-segment--buffer-info)))))
          (concat
           (s-truncate
            durand-buffer-name-max
            buffer-info))))

            #+END_SRC

*** No Display =flycheck= in Modeline
    I'm don't love =flycheck= in =modeline=, so I turn off that.

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (setq flycheck-mode-line nil)

    #+END_SRC

*** Enable Modeline
    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (defvar my-modeline-ignored-modes '(company-mode))

      (use-package doom-modeline
          :ensure t
          :defer 0.1
          :init
          (size-indication-mode t)
          :custom
          (doom-modeline-buffer-file-name-style 'buffer-name)
          (doom-modeline-icon nil)
          (xah-fly-insert-state-p nil)
          :config
          (display-time-mode t)
          (doom-modeline-def-modeline 'main
              '(bar
                my-matches
                drag
                buffer-info-durand
                time
                pomidor
                word-count
                selection-info)
            '(objed-state
              persp-name
              grip
              irc
              gnus
              github
              debug
              repl
              input-method
              indent-info
              buffer-encoding
              major-mode
              process
              vcs
              checker))
          (doom-modeline-set-modeline 'main t))

          #+END_SRC

** Fonts

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (set-face-attribute 'default nil :font "Consolas" :height 250)
     (set-frame-font "Consolas" nil t)

     #+END_SRC

   #+RESULTS:

** Highlight Current Line

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (global-hl-line-mode 1)

     #+END_SRC

** Centering

   I

** View Break Page Lines
   I am use [[https://github.com/purcell/page-break-lines][page-break-lines]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package page-break-lines
         :ensure t
         :init
         (global-page-break-lines-mode 38))

         #+END_SRC

* Developer Environment
** Projects Management
   I am use [[https://github.com/bbatsov/projectile][projectile]]:

   #+BEGIN_SRC emacs-lisp  :tangle  ~/init.el

     (use-package projectile
         :custom
       (projectile-project-search-path '("~/projects/"))
       (projectile-completion-system 'helm)
       :init (projectile-mode 1)
       :bind
       (("S-<f5>" . projectile-test-project)
        ("<f5>"   . projectile-run-project)))

     (projectile-mode 1)

     #+END_SRC

     #+RESULTS:
     : t

*** Projectile with Helm
    I am use offical [[https://github.com/bbatsov/helm-projectile][helm-projectile]] I am press =SPC j= and find file in current project:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package helm-projectile
          :ensure t
          :bind (:map xah-fly-command-map
                      ("SPC j" . 'helm-projectile-find-file)))

                      #+END_SRC

** Regexp IDE
   I am use [[https://github.com/jwiegley/regex-tool][regex-tool]] for testing regexp in Emacs

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package regex-tool
         :ensure t
         :init
         (add-hook 'regex-tool-mode-hook (lambda () (toggle-frame-maximized))))

         #+END_SRC

** Git
   I am use super famous [[https://github.com/magit/magit][magit]]:

   #+BEGIN_SRC emacs-lisp  :tangle  ~/init.el

     (use-package magit :ensure t)

     #+END_SRC

*** Fly View Authors of Changes
    For this I am use [[https://github.com/Artawower/blamer.el][blamer]]:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package blamer
          :ensure t
          :defer 20
          :custom
          (blamer-idle-time 0.3)
          (blamer-min-offset 70)
          :custom-face
          (blamer-face ((t :foreground "#7a88cf"
                           :background nil
                           :height 140
                           :italic t)))
          )

          #+END_SRC

*** Undo with Git
    I am use [[https://github.com/jwiegley/git-undo-el][git-undo]]:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package git-undo
          :init
        (defun fast-exec-define-git-undo-keymaps ()
          "Bind `git-undo' and `fast-exec'."
          (fast-exec/some-commands
           ("Undo via Git" 'git-undo)))
        (fast-exec/register-keymap-func 'fast-exec-define-git-undo-keymaps)
        (fast-exec/reload-functions-chain))

        #+END_SRC

*** Git Major Modes
    As major modes of (.github, gitconfig) I am use [[https://github.com/magit/git-modes][git-modes]]:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package git-modes
          :ensure t)

          #+END_SRC

*** Genreate .gitignore
    I am use [[https://github.com/jupl/helm-gitignore][helm-gitignore]]:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package helm-gitignore
          :init
        (defun fast-exec-helm-gitignore-keys ()
          "Bind of `helm-gitignore' and `fast-exec'."
          (fast-exec/some-commands
           ("Generate Gitignore" 'helm-gitignore)))
        (fast-exec/register-keymap-func 'fast-exec-helm-gitignore-keys)
        (fast-exec/reload-functions-chain))

        #+END_SRC

** View Directories
   I am use =dired=:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el
     (add-hook 'dired-mode-hook (lambda () (dired-hide-details-mode 1)))
     #+END_SRC

** Just Run Current File
   I am use [[https://github.com/emacsorphanage/quickrun][quickrun]].  [[https://github.com/emacsorphanage/quickrun][Quickrun]] has command which just run current
   file (without other sheet (with any sheet see [[*Run Command][Run Command]])).  I
   press =S-f5= in any =major-mode= and current file was runned or
   compiled

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package quickrun
         :ensure t
         :bind (("S-<f5>" . quickrun))      ; in section of config *Run
                                             ; Command, I rebind this key
                                             ; binding, I'm not delete this
                                             ; bind, because if section wasn't
                                             ; load, then all will work normally
         )

   #+END_SRC

** Run Command
   I am use [[https://github.com/bard/emacs-run-command][run-command]] for run special commands for special files:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defvar run-command-last-recipe nil
       "Last runned recipe of `run-command'.")

     (use-package run-command
         :ensure t
         :custom
         (run-command-completion-method 'helm)
         :bind ((:map xah-fly-command-map)
                ("SPC , c" . 'run-command)
                ("S-<f5>"  . 'my-run-last-command))
         :config
         (defun run-command--run (command-spec)
           "Run `COMMAND-SPEC'.  Back end for helm and ivy actions."
           (message "ok?")
           (setq-local run-command-last-recipe command-spec)
           (eval (run-command--from-spec command-spec)))
         (defun my-run-last-command ()
           "Run command which was runned last, if commands wasn't run, then `quickrun'."
           (interactive)
           (if run-command-last-recipe
               (run-command--run run-command-last-recipe)
             (quickrun))))



   #+END_SRC

*** Run Command Recipes
    I am use [[https://github.com/semenInRussia/emacs-run-command-recipes/][run-command-recipes]]:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package run-command-recipes
          :ensure t
          :config
          (run-command-recipes-use-all))

          #+END_SRC
** Projects with Templates
   I am use [[https://github.com/chrisbarrett/skeletor.el][skeletor]] for creating new projects by temlate:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package skeletor
         :ensure t
         :custom
         (skeletor-init-with-git nil)
         (skeletor-project-directory "~/projects")
         (skeletor-completing-read-function completing-read-function))

         #+END_SRC
** Snitch
   I am use [[https://github.com/tsoding/snitch][snitch]] for managing TODOs

*** Highlight TODOs
    I am use [[https://github.com/tarsius/hl-todo][hl-todo]]:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (use-package hl-todo
          :ensure t
          :config (global-hl-todo-mode))

          #+END_SRC
*** Run Snitch Commands
    I am use =run-command= (see in this config) for run command:

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (defun run-command-recipe-snitch ()
        "Recipes of `run-command' for snitch."
        (when (f-directory-p (f-join (projectile-acquire-root)
                                     ".git"))
          (list
           (list :command-name "sntich-list"
                 :display "See List of TODOs from via Snitch"
                 :command-line "snitch list")
           (list :command-name "sntich-report"
                 :display "Report to VC TODOs of Project via Snitch"
                 :command-line "snitch list"))))

      (add-to-list 'run-command-recipes 'run-command-recipe-snitch)

      #+END_SRC

** Organization
   I am use [[https://orgmode.org/manual/Agenda-Views.html][org-agenda]] for managing of TODOs and DONEs and other, my
   all todo's saved in one file =agenda.org=:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (setq org-agenda-files '("~/agenda.org"))

     (defun my-open-main-agenda-file ()
       "Open \"~/agenda.org\"."
       (interactive)
       (find-file "~/agenda.org"))

     (global-set-key (kbd "<f9>") #'org-agenda)
     (define-key xah-fly-command-map (kbd "SPC <f9>") #'org-todo-list)

     (global-set-key (kbd "<f5>") #'my-open-main-agenda-file)
   #+END_Src

** Notes
   I am create own simple system of notes:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defgroup my-notes nil
       "My own simple system of notes."
       :group 'tools)

     (defcustom my-notes-extension "org"
       "Extension of notes, defaults to org."
       :type 'string
       :group 'my-notes)

     (defcustom my-notes-categories-list-file-path
       "~/notes/categories.txt"
       "Path to file which contains list of categories."
       :type 'string
       :group 'my-notes)

     (defun my-notes-parse-categories ()
       "Find notes' categories in special path.
     See `my-notes-categories-list-file-path'"
       (->>
        my-notes-categories-list-file-path
        (f-read)
        (s-trim)
        (s-lines)
        (-remove #'s-blank-p)))

     (defcustom my-notes-categories
       (my-notes-parse-categories)
       "List of tags of notes."
       :group 'my-notes
       :type '(repeat symbol))

     (defcustom my-notes-templates-dir
       "~/notes/templates"
       "Directory in which will save templates of my notes."
       :type 'string
       :group 'my-notes)

     (defcustom my-notes-default-template
       "~/notes/default.org"
       "Default template for notes."
       :type 'string
       :group 'my-notes)

     (defcustom my-notes-directory
       "~/notes"
       "Main directory of my notes."
       :type 'string
       :group 'my-notes)

     (defun my-notes-read-note ()
       "Read from user note."
       (my-notes-note
        :title (read-string "Please, enter title of note: ")
        :category (my-notes-read-category)))

     (defun my-notes-read-category (&optional prompt)
       "Read category from user with PROMPT."
       (setq prompt (or prompt "Choose category, please: "))
       (completing-read prompt my-notes-categories))

     (defun my-notes-find ()
       "Find one of notes."
       (interactive)
       (let* ((category (my-notes-read-category))
              (title
               (->>
                category
                (my-notes-titles-of-category)
                (completing-read "Choose one of notes, please: ")
                (my-normalize-string))))
         (my-notes-note :title title :category category)))

     (defun my-notes-visit (note)
       "Visit NOTE's file."
       (interactive (list (my-notes-find)))
       (->> note (my-notes-note-path) (find-file)))

     (defun my-notes-change-category-of-note (note new-category)
       "Change category of NOTE to NEW-CATEGORY."
       (interactive
        (list
         (my-notes-find)
         (my-notes-read-category "New category, please: ")))
       (let ((new-note
              (my-notes-note
               :title (my-notes-note-title note)
               :category new-category)))
         (my-notes-category-mkdir new-category)
         (f-move
          (my-notes-note-path note)
          (my-notes-note-path new-note))))

     (defun my-notes-delete (note)
       "Delete NOTE."
       (interactive (list (my-notes-find)))
       (->> note (my-notes-note-path) (f-delete)))

     (defun my-notes-titles-of-category (category)
       "Get list of notes' titles of CATEGORY."
       (->>
        category
        (my-notes-category-path)
        (my-files-with-extension my-notes-extension)
        (-map #'f-base)
        (-map #'my-humanize-string)))

     (defun my-notes-category-path (category)
       "Get path to CATEGORY's directory."
       (->> category (my-normalize-string) (f-join my-notes-directory)))

     (defun my-notes-category-mkdir (category)
       "If directory of CATEGORY not created, then create its."
       (->>
        category
        (my-notes-category-path)
        (f-mkdir)))

     (defun my-notes-visit-category-template (category)
       "Create or visit template for CATEGORY."
       (interactive (list (my-notes-read-category)))
       (->> category (my-notes-category-template-path) (find-file)))

     (defun my-notes-new (note &optional is-template-as-snippet)
       "Create new note from NOTE object.
     If IS-TEMPLATE-AS-SNIPPET is t, then expand template of note as YAS snippet"
       (interactive (list (my-notes-read-note) t))
       (find-file (my-notes-note-path note))
       (my-notes-note-insert-template note is-template-as-snippet))

     (defun my-notes-buffer-to-note (buffer note)
       "Save BUFFER as NOTE."
       (interactive
        (list
         (current-buffer)
         (my-notes-note
          :title (read-string "Name of note, please: " (buffer-name))
          :category (my-notes-read-category))))
       (with-current-buffer buffer
         (let ((text (buffer-string)))
           (kill-buffer buffer)
           (my-notes-new note)
           (insert text))))

     (defclass my-notes-note ()
       ((title :initarg :title :accessor my-notes-note-title)
        (category :initarg :category :accessor my-notes-note-category))
       "My note object.")

     (defun my-notes-add-note-extension (s)
       "Add `my-notes-extension' to S."
       (f-swap-ext s my-notes-extension))

     (defun my-notes-note-path (note)
       "Get path to file of note NOTE."
       (->>
        note
        (my-notes-note-title)
        (my-normalize-string)
        (my-notes-add-note-extension)
        (f-join (my-notes-category-path (my-notes-note-category note)))))

     (defun my-notes-note-template-path (note)
       "Get path of template for NOTE."
       (let ((template-for-category
              (->>
               note
               (my-notes-note-category)
               (my-notes-category-template-path))))
         (if (f-exists-p template-for-category)
             template-for-category
           my-notes-default-template)))

     (defun my-notes-category-template-path (category)
       "Get path of CATEGORY's template."
       (->>
        category
        (my-normalize-string)
        (f-join my-notes-templates-dir)
        (my-notes-add-note-extension)))

     (defun my-notes-note-insert-template (note &optional is-as-snippet)
       "Insert template for NOTE.
     If IS-AS-SNIPPET is t, then expand template as YAS snippet"
       (let ((template (my-notes-note-get-template-string note)))
         (if is-as-snippet
             (yas-expand-snippet template)
           (insert template))))

     (defun my-notes-note-get-template-string (note)
       "Get string of template for NOTE."
       (->>
        note
        (my-notes-note-template-path)
        (f-read)
        (s-replace "{title}" (my-notes-note-title note))
        (s-replace "{category}" (my-notes-note-category note))))

     (defun my-notes-new-category (category)
       "Add CATEGORY list of categories."
       (interactive "sName of new category, please: ")
       (->>
        my-notes-categories
        (cons category)
        (my-notes-change-categories)))

     (defun my-notes-rename-category (category new-name)
       "Change name of CATEGORY to NEW-NAME."
       (interactive
        (let* ((category (my-notes-read-category))
               (new-name
                (read-string "New name of this category, please: " category)))
          (list category new-name)))
       (my-notes-rename-category-directory category new-name)
       (my-notes-rename-category-template category new-name)
       (->>
        my-notes-categories
        (-replace category new-name)
        (my-notes-change-categories)))

     (defun my-notes-rename-category-directory (category new-name)
       "Rename directory of CATEGORY to NEW-NAME."
       (my-try-move
        (my-notes-category-path category)
        (my-notes-category-path new-name)))

     (defun my-notes-rename-category-template (category new-name)
       "Rename template of CATEGORY to template of NEW-NAME."
       (my-try-move
        (my-notes-category-template-path category)
        (my-notes-category-template-path new-name)))

     (cl-defun my-notes-delete-category (category &optional (is-delete-notes t))
       "Delete CATEGORY and files of this category if IS-DELETE-NOTES is true."
       (interactive
        (list
         (my-notes-read-category)
         (y-or-n-p "Is delete notes of this category? ")))
       (when is-delete-notes ;nofmt
         (my-notes-delete-notes-of-category category))
       (my-notes-delete-category-template category)
       (->>
        my-notes-categories
        (remove category)
        (my-notes-change-categories)))

     (defun my-notes-delete-notes-of-category (category)
       "Delete each note of CATEGORY."
       (-> category (my-notes-category-path) (my-try-delete t)))

     (defun my-notes-delete-category-template (category)
       "Delete template for CATEGORY."
       (->> category (my-notes-category-template-path) (my-try-delete)))

     (defun my-notes-change-categories (new-categories)
       "Change list of categories to NEW-CATEGORIES with change category's file."
       (setq my-notes-categories new-categories)
       (my-notes-change-categories-list-file new-categories))

     (defun my-notes-change-categories-list-file (new-categories)
       "Change categories with file in which its writed to NEW-CATEGORIES."
       (f-write-text
        (s-join "\n" new-categories)
        'utf-8
        my-notes-categories-list-file-path))

     (defun fast-exec-my-notes-keys ()
       "Get some useful keymaps of  `fast-exec' for my-notes."
       (fast-exec/some-commands
        ("New Note" 'my-notes-new)
        ("Buffer to Note" 'my-notes-buffer-to-note)
        ("Delete Note" 'my-notes-delete)
        ("Change Category of Note" 'my-notes-change-category-of-note)
        ("New Category of Notes" 'my-notes-new-category)
        ("Delete Category of Notes" 'my-notes-delete-category)
        ("Rename Category of Notes" 'my-notes-rename-category)
        ("Find Template for Note" 'my-notes-visit-category-template)
        ("Find Note" 'my-notes-visit)))

     (fast-exec/register-keymap-func 'fast-exec-my-notes-keys)
     (fast-exec/reload-functions-chain)
     #+END_SRC

* MIPT
** Management of MIPT Files
   I am make homework of [[https://mipt.ru][MIPT]], so I make small script, which create
   new file of homework of mipt's homework:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defcustom my-mipt-dir "c:/Users/hrams/Documents/mfti-solutions"
       "Path to directory in which will saved solutions of MIPT tasks.")

     (defcustom my-mipt-lessons '("f" "m") "Lessons of MIPT.")

     (defclass my-mipt-task ()
       ((class :initform nil :initarg :class :accessor my-mipt-task-class)
        (lesson :initform nil
                :initarg :lesson
                :accessor my-mipt-task-lesson)
        (section :initform nil
                 :initarg :section
                 :accessor my-mipt-task-section)
        (kind :initform nil ;nofmt
              :initarg :kind
              :accessor my-mipt-task-kind)   ; 'control or 'normal
        (number  :initform nil
                 :initarg :number
                 :accessor my-mipt-task-number))
       "Object for task of MIPT.")

     (defvar my-mipt-found-task
       (my-mipt-task)
       "Object of `my-mipt-task', will set automatically when find task.")

     (defvar my-mipt-last-task
       nil
       "Object of `my-mipt-task', will set automatically when find task.")

     (defun my-mipt-task-control-p (task)
       "Return t, when TASK is control."
       (eq (my-mipt-task-kind task) 'control))

     (defun my-mipt-task-normal-p (task)
       "Return t, when TASK is normal, no control."
       (not (my-mipt-task-control-p task)))

     (defun my-mipt-task-parse (filename)
       "Parse from FILENAME MIPT task."
       (when (s-matches-p ".+-.-.+-.+\\(-control\\)?\\.tex" filename)
         (-let*
             ((base (f-base (f-no-ext filename)))
              ((class lesson section num is-control)
               (s-split "-" base)))
           (my-mipt-task
            :class (string-to-number class)
            :lesson lesson
            :section (string-to-number section)
            :number (string-to-number num)
            :kind (if (stringp is-control) 'control 'normal)))))

     (defun my-mipt-task-path (task)
       "Get path to TASK's solution."
       (->>
        (format
         "%s-%s-%s-%s%s.tex"
         (my-mipt-task-class task)
         (my-mipt-task-lesson task)
         (my-mipt-task-section task)
         (my-mipt-task-number task)
         (if (my-mipt-task-control-p task) "-control" ""))
        (f-join my-mipt-dir)))

     (defun my-mipt-last-task ()
       "Return last opened task via `recentf'."
       (->>
        recentf-list
        (-find #'my-mipt-task-parse)
        (my-mipt-task-parse)))

     (defun my-mipt-visit-last-task ()
       "Visit last opened task searched via `my-mipt-last-task'."
       (interactive)
       (my-mipt-task-visit (my-mipt-last-task)))

     (defun my-mipt-next-task ()
       "Return next task, after last found task."
       (interactive)
       (let ((next-task (my-mipt-last-task)))
         (incf (my-mipt-task-number next-task))
         (if (interactive-p) (my-mipt-task-visit next-task) next-task)))

     (defun my-mipt-task-visit (task)
       "Visit file of TASK's solution."
       (interactive (list (my-mipt-find-task)))
       (->> task (my-mipt-task-path) (find-file)))

     (defun my-mipt-all-tasks ()
       "Return all mipt tasks in special dir `my-mipt-dir'."
       (->> my-mipt-dir (f-files) (-keep #'my-mipt-task-parse)))

     (defun my-mipt-find-task ()
       "Find task of MIPT from created."
       (interactive)
       (setq my-mipt-found-task (my-mipt-task))
       (->>
        (my-mipt-all-tasks)
        (my-mipt--find-lesson-from-tasks)
        (my-mipt--find-class-from-tasks)
        (my-mipt--find-section-from-tasks)
        (my-mipt--find-kind-from-tasks)
        (my-mipt--find-number-from-tasks))
       (my-mipt-complete-task my-mipt-found-task))

     (defun my-mipt--find-lesson-from-tasks (tasks)
       "From TASKS find lesson, save in special variable, and return filtered TASKS.
     Special variable is `my-mipt-found-task'"
       (let ((lesson (my-mipt-read-lesson)))
         (setf (my-mipt-task-lesson my-mipt-found-task) lesson)
         (->>
          tasks
          (--filter (string-equal (my-mipt-task-lesson it) lesson)))))

     (defun my-mipt-read-lesson ()
       "Read from user MIPT's lesson."
       (completing-read "Choose one of MIPT lessons, please: " my-mipt-lessons))

     (defun my-mipt--find-class-from-tasks (tasks)
       "From TASKS find class, save in special variable, and return filtered TASKS.
     Special variable is `my-mipt-found-task'"
       (let* ((class (my-mipt-choose-one-of-task-classes tasks)))
         (setf (my-mipt-task-class my-mipt-found-task) class)
         (->> tasks (--filter (= (my-mipt-task-class it) class)))))

     (defun my-mipt-choose-one-of-task-classes (tasks)
       "Take TASKS and choose one of classes."
       (->>
        tasks
        (-map #'my-mipt-task-class)
        (my-max)
        (my-mipt-read-class)))

     (defun my-mipt-read-class (&optional default)
       "Read from user class of MIPT task, defaults to DEFAULT."
       (read-number "Choose one of MIPT classes, please: " default))

     (defun my-mipt--find-section-from-tasks (tasks)
       "From TASKS find section, save in special variable, and return filtered TASKS.
     Special variable is `my-mipt-found-task'"
       (let* ((section (my-mipt-choose-one-of-task-sections tasks)))
         (setf (my-mipt-task-section my-mipt-found-task) section)
         (->> tasks (--filter (= (my-mipt-task-section it) section)))))

     (defun my-mipt-choose-one-of-task-sections (tasks)
       "Take TASKS and choose one of sections."
       (->>
        tasks
        (-map #'my-mipt-task-section)
        (my-max)
        (my-mipt-read-section)))

     (defun my-mipt-read-section (&optional default)
       "Read from user section of MIPT task, defaults to DEFAULT."
       (read-number "Enter section of MIPT task, please: " default))

     (defun my-mipt--find-kind-from-tasks (tasks)
       "From TASKS find kind, save in special variable, and return filtered TASKS.
     Special variable is `my-mipt-found-task'"
       (let ((kind (my-mipt-choose-one-of-task-kinds tasks)))
         (setf (my-mipt-task-kind my-mipt-found-task) kind)
         (->> tasks (--filter (eq (my-mipt-task-kind it) kind)))))

     (defun my-mipt-choose-one-of-task-kinds (tasks)
       "Take TASKS and choose one of kinds."
       (let* ((is-was-normal-tasks (-any #'my-mipt-task-normal-p tasks))
              (is-normal
               (if is-was-normal-tasks
                   (y-or-n-p "Your task normal? ")
                 (not (y-or-n-p "Your task control? ")))))
         (if is-normal 'normal 'control)))

     (defun my-mipt-read-kind (&optional default)
       "Read from user kind of MIPT task, defaults to DEFAULT."
       (if (y-or-n-p "Your task normal? ") 'normal 'control))

     (defun my-mipt--find-number-from-tasks (tasks)
       "From TASKS find number, save in special variable, and return filtered TASKS.
     Special variable is `my-mipt-found-task'"
       (let* ((number (my-mipt-choose-one-of-task-numbers tasks)))
         (setf (my-mipt-task-number my-mipt-found-task) number)
         (->> tasks (--filter (= (my-mipt-task-number it) number)))))

     (defun my-mipt-choose-one-of-task-numbers (tasks)
       "Take TASKS and choose one of classes."
       (let* ((numbers (-map #'my-mipt-task-number tasks))
              (default (my-max numbers)))
         (my-completing-read-numbers
          "Please, choose number of MIPT task: "
          numbers
          nil
          nil
          default)))

     (defun my-mipt-read-number (&optional default)
       "Read from user number of MIPT's task, defaults to DEFAULT."
       (read-number "Please, type number of MIPT task: " (or default 1)))

     (defun my-mipt-complete-task (task)
       "Complete all fields of TASK, and return modified TASK."
       (my-mipt-task
        :class (or (my-mipt-task-class task) (my-mipt-read-class))
        :lesson (or (my-mipt-task-lesson task) (my-mipt-read-lesson))
        :section (or (my-mipt-task-section task) (my-mipt-read-section))
        :kind (or (my-mipt-task-kind task) (my-mipt-read-kind))
        :number (or (my-mipt-task-number task) (my-mipt-read-number))))

     (defun fast-exec-mipt-keys ()
       "Get some useful keymaps of  `fast-exec' for MIPT."
       (fast-exec/some-commands
        ("Next MIPT Task" 'my-mipt-next-task)
        ("Open Last MIPT Task" 'my-mipt-visit-last-task)
        ("Find MIPT Task" 'my-mipt-task-visit)))

     (fast-exec/register-keymap-func 'fast-exec-mipt-keys)
     (fast-exec/reload-functions-chain)

   #+END_SRC

** Copy Content of File as MIPT Solution
   MIPT has bug, when LaTeX's source is too big, source will limited,
   so I need to compess my code, function
   =my-copy-buffer-content-as-mipt-solution= make this, I am press on
   =SPC l c= in =LaTeX-mode=, and this copy compessed variant of
   current buffer:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defun my-copy-buffer-content-as-mipt-solution ()
    "Take content of current buffer, compress it and copy its."
    (interactive)
    (->> (buffer-string) (my-compress-latex-source) (kill-new)))

  (defun my-compress-latex-source (source)
    "Take SOURCE and return compressed variant."
    (->>
     source
     (s-replace "\n" " ")
     (s-replace "\\begin{equation}" "\\[")
     (s-replace "\\end{equation}" "\\]")
     (s-append "Так как ваш сайт не любит большие решения, ")
     (s-append "то оно было уменьшено с помощью программного кода")))

  (bind-keys
   :map my-latex-local-map
   ("c" . my-copy-buffer-content-as-mipt-solution))

#+END_SRC

#+RESULTS:
: my-copy-buffer-content-as-mipt-solution

