#+TITLE: Config of Emacs from semenInRussia
#+AUTHOR: semenInRussia

* Hi!
  Hello, This is configuration of Emacs from semenInRussia!
  I create this configuration with help of [[https://github.com/daviwil/emacs-from-scratch/][this cool repo]].
  
  My moto is "Good Luck!", so my homepage is "Good Luck":

  #+BEGIN_SRC emacs-lisp :tangle ~/init.el

    (setq initial-buffer-choice "~/Start.org")

  #+END_SRC

* Package Management - base 
** use-package
   I am use [[https://github.com/jwiegley/use-package][use-package]]:
   
   #+BEGIN_SRC emacs-lisp :tangle ~/init.el
     (require 'package)

     (setq package-archives
           '(("melpa-stable" . "http://stable.melpa.org/packages/")
             ("melpa"        . "https://melpa.org/packages/")
             ("org"          . "https://orgmode.org/elpa/")
             ("elpa"         . "https://elpa.gnu.org/packages/")))

     (package-initialize)
     (unless package-archive-contents
         (package-refresh-contents))

     (unless (package-installed-p 'use-package)
         (package-install 'use-package))

     (require 'use-package)
     #+END_SRC
** Packages Not in MELPA/ELPA/ORG-ELPA
*** Stranger Packages

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

(add-to-list 'load-path "~/.emacs.d/lisp")

#+END_SRC

*** My Packages

    #+BEGIN_SRC emacs-lisp :tangle ~/init.el

      (add-to-list 'load-path "~/projects/fast-exec.el")
      (add-to-list 'load-path "~/projects/porth-mode")
      (add-to-list 'load-path "~/projects/emacs-run-command")
      (add-to-list 'load-path "~/projects/simple-indention.el")

      #+END_SRC

* Emacs Lisp
  I am use some packages for simple develop on Emacs Lisp
** Libraries
*** s
    This is [[https://github.com/magnars/s.el][s]]:
    #+BEGIN_SRC emacs-lisp :tangle ~/init.el
      (use-package s :ensure t)
      #+END_SRC
      
*** f
    This is [[https://github.com/rejeep/f.el][f]]:
    
    #+BEGIN_SRC emacs-lisp  :tangle  ~/init.el
      (use-package f :ensure t)
      #+END_SRC
      
*** Dash
    This is [[https://github.com/magnars/dash.el][dash:]]
    #+BEGIN_SRC emacs-lisp  :tangle  ~/init.el

      (use-package dash :ensure t :init (global-dash-fontify-mode 1))

      #+END_SRC

* Info about me for Emacs

  #+BEGIN_SRC emacs-lisp :tangle ~/init.el

    (setq user-full-name    "Semen Khramtsov"
          user-mail-address "hrams205@gmail.com"
          user-birthday     "2007-01-29"
          user-name         "semenInRussia"
          user-os           "Windows" ; "Windows" or "Linux"
          )


    (defun user-os-windows-p ()
        "If user have os Windows, then return t.
    Info take from var `user-os`, user must set it."
        (interactive)
        (s-equals? user-os "Windows"))

   #+END_SRC

** Congurlation me with my Birthday!

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (if (s-equals? (format-time-string "%Y-%m-%d") user-birthday)
         (animate-birthday-present))

         #+END_SRC

* Organize Editing
** Snippets
   I am use [[https://github.com/joaotavora/yasnippet][yasnippet]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el
     (use-package yasnippet
         :ensure t
         :init
         (yas-global-mode 1)
         :custom
         (yas-snippet-dirs '("~/.emacs.d/snippets"))
         (yas-wrap-around-region t)
         :bind (:map yas-keymap
                     ("<return>" . yas-exit-all-snippets)))

   #+END_SRC
         
   And [[https://github.com/emacsmirror/yasnippet-classic-snippets][yasnippet-classic-snippets]] for basic snippets' collection:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el
     (use-package yasnippet-classic-snippets :ensure t)
   #+END_SRC

** Linters
   I am use [[https://www.flycheck.org/en/latest/][flycheck]]:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package flycheck
         :ensure t
         :config
         '(custom-set-variables
           '(flycheck-display-errors-function
             #'flycheck-pos-tip-error-messages))
         (global-flycheck-mode 1))

   #+END_SRC

** Autocomplete
   I am use [[http://company-mode.github.io][company-mode]], I am set delay beetween typing text and viewing hints to
   0.8 seconds:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (use-package company
         :ensure t
         :custom
         (company-idle-delay                 0.3)
         (company-minimum-prefix-length      2)
         (company-show-numbers               t)
         (company-tooltip-limit              15)
         (company-tooltip-align-annotations  t)
         (company-tooltip-flip-when-above    t)
         (company-dabbrev-ignore-case        nil)
         :config
         (add-to-list 'company-backends 'company-keywords)
         (global-company-mode 1))

   #+END_SRC

   And for =yasnippet= I am use code from [[https://emacs.stackexchange.com/questions/10431/get-company-to-show-suggestions-for-yasnippet-names][this]] stackexchange:

   #+BEGIN_SRC emacs-lisp :tangle ~/init.el

     (defvar company-mode/enable-yas t
       "Enable yasnippet for all backends.")

     (defun company-mode/backend-with-yas (backend)
         (if (or (not company-mode/enable-yas)
                 (and (listp backend) (member 'company-yasnippet backend)))
             backend
             (append (if (consp backend) backend (list backend))
                     '(:with company-yasnippet))))

     (setq company-backends
           (mapcar #'company-mode/backend-with-yas company-backends))

    #+END_SRC

*** More Pretty Auto Complete
    I am use popular [[https://github.com/sebastiencs/company-box][company-box]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package company-box
      :ensure t
      :hook (company-mode . company-box-mode))

#+END_SRC

** Format All Code
   Each programmer need to format code for this I am use [[https://github.com/lassik/emacs-format-all-the-code][format-all]], its support 65 languages:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package format-all
      :ensure t)

#+END_SRC

*** I am Russian!
    I am need to use russian letters as english in key hots:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el
#+END_SRC

** Main keymaps
   I am use [[https://github.com/xahlee/xah-fly-keys][xah-fly-keys]], this as VIM, but keymaps created for keyboard (in VIM keymaps created for easy remember):
   
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package xah-fly-keys
      :config
      (xah-fly-keys-set-layout "qwerty")
      (xah-fly-keys 1)
      (define-key xah-fly-command-map (kbd "SPC l") nil)
      (define-key xah-fly-command-map (kbd "SPC j") nil)
      (define-key xah-fly-command-map (kbd "SPC SPC") nil))

#+END_SRC
*** Easy Create Major Modes Maps
    I am use =use-package=, so I'm add flag =:major-mode-map= for create major modes in =use-package= macro, I am bind local major mode map to =SPC l=:


 #+BEGIN_SRC emacs-lisp :tangle ~/init.el

   (defvar my-local-major-mode-map nil
     "My map for current `major-mode'")

   (defun my-local-major-mode-map-run ()
       "Run `my-local-major-mode-map'."
       (interactive)
       (set-transient-map my-local-major-mode-map))

   (define-key xah-fly-command-map (kbd "SPC l") 'my-local-major-mode-map-run)

 #+END_SRC

**** Setup for =:major-mode-map=

     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

       (add-to-list 'use-package-keywords :major-mode-map)

     #+END_SRC

**** Normalizer for =:major-mode-map=
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defun use-package-normalize/:major-mode-map (name keyword args)
      "Normalizer of :major-mode-map for `use-package'."
      (let* (map-name modes)
          (if (eq (-first-item args) t) ; All by Default
              (list (symbol-name name) (list name))
              (cl-typecase (-first-item args)
                (list (setq modes (-first-item args)))
                (symbol (setq map-name (symbol-name (-first-item args))))
                (string (setq map-name (-first-item args))))
              (cl-typecase (-second-item args)
                (list (setq modes (-first-item args)))
                (symbol (setq map-name (symbol-name (-first-item args))))
                (string (setq map-name (-first-item args))))
              (message "map-name is %s" map-name)
              (message "modes is %s" modes)
              (list
               (or map-name (symbol-name name))
               modes))))

#+END_SRC

**** =major-mode-map='s Handler
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defun use-package-handler/:major-mode-map (name keyword
                                              map-name-and-modes rest state)
      (let* ((map-name (car map-name-and-modes))
             (modes (-second-item map-name-and-modes))
             (modes-hooks (--map (intern (s-append "-hook" (symbol-name it)))
                                 modes))
             (map (intern (s-concat "my-" map-name "-local-map"))))
          (setq rest
                (-concat
                 rest
                 `(:config
                   ((unless (boundp ',map)
                        (define-prefix-command ',map))
                    (--each ',modes-hooks
                        (add-hook it
                                  (lambda ()
                                      (setq-local my-local-major-mode-map
                                                  ',map))))))))
          (use-package-process-keywords name rest)))

#+END_SRC

** Fast Executing Command
   I am use [[https://github.com/semenInRussia/fast-exec.el][fast-exec]]:
   
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (require 'fast-exec)

  (fast-exec/enable-some-builtin-supports haskell-mode
                                          flycheck
                                          magit
                                          deadgrep
                                          projectile
                                          skeletor
                                          yasnippet
                                          format-all
                                          wikinforg
                                          suggest
                                          devdocs
                                          helm-wikipedia)

  (fast-exec/initialize)

  (define-key xah-fly-command-map (kbd "=") 'fast-exec/exec)

#+END_SRC

** Functions for Define Keys

   Function =define-key-when= is wrap on =define-key=, but function DEF will call when
will pressed KEY in KEYMAP and when CONDITION will true:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defun keymap-to-list (keymap)
      "Convert `KEYMAP` to list."
      (--filter (ignore-errors '((cat it) (cdr it))) (-drop 1 keymap)))


  (defun function-of-key (keymap key)
      "Get function bound on `KEY` in `KEYMAP`."
      (let* ((list-keymap (keymap-to-list keymap))
             (kbd-key (kbd key))
             (key-chars (string-to-list kbd-key))
             (head-key-char (-first-item key-chars))
             (tail-key-chars (-drop 1 key-chars))
             (object-on-key (--filter (ignore-errors
                                          (eq head-key-char (-first-item it)))
                                      list-keymap))
             )
          (cond
            (tail-key-chars
             (function-of-key object-on-key
                              (chars-to-string tail-key-chars)))
            (t (cdr (-first-item object-on-key)))))
      )


  (defun chars-to-string (chars)
      "Convert list of `CHARS` to string."
      (--reduce-from (s-concat acc (char-to-string it)) "" chars))


  (defmacro define-key-when (keymap key def condition)
      "Macro for define keymaps for `rectangle-mode` in `xah-fly-command-mode`"
      `(define-key ,keymap (kbd ,key)
           (lambda ()
               (interactive)
               (if (funcall ,condition)
                   (call-interactively ,def)
                   (call-interactively ',(function-of-key (eval keymap) key))))))

#+END_SRC

** Search
*** Search in File
   
   I am press ='= for search word:
   
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package swiper-helm
      :ensure t
      :bind (:map xah-fly-command-map
                  ("'" . swiper-helm)))

#+END_SRC

*** Search in Very Some File
    I am use [[https://github.com/Wilfred/deadgrep][deadgrep]], because I am love =Rust=:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package deadgrep
      :ensure t
      :bind (:map
             xah-fly-command-map
             ("SPC '" . deadgrep)))

#+END_SRC

** Search and Replace
   I am use =SPC r= for replace word in buffer, and =SPC SPC r= for replace word in project:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (define-key xah-fly-command-map (kbd "SPC SPC r") 'projectile-replace)

#+END_SRC

** Navigation beetween Functions/Classes/etc.
   I am use =imenu= with =Helm= and keymap =SPC SPC SPC=:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package semantic
      :ensure t)

  (use-package imenu
      :custom (imenu-auto-rescan t))

  (bind-keys :map xah-fly-command-map
             ("SPC SPC SPC" . helm-semantic-or-imenu))

#+END_SRC

*** In Project
    For Imenu In Project I am use [[https://github.com/vspinu/imenu-anywhere][imenu-anywhere]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package imenu-anywhere
      :ensure t
      :bind (:map xah-fly-command-map
                  ("SPC SPC n" . imenu-anywhere)))

#+END_SRC

** Smart Comment/Uncomment
   I am use [[https://github.com/remyferre/comment-dwim-2][comment-dwim-2]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package comment-dwim-2
      :ensure t
      :bind (:map xah-fly-command-map
                  ("z" . comment-dwim-2)))

#+END_SRC

** Jump to Defnition
   I am use [[https://github.com/jacktasia/dumb-jump][cool package dumb-jump]] for jump to defnition in 50+ languages:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package rg
      :ensure t)

  (use-package dumb-jump
      :ensure t
      :custom
      (dumb-jump-force-searcher 'rg)
      (dumb-jump-prefer-searcher 'rg)
      :bind (:map xah-fly-command-map ("SPC SPC ." . dumb-jump-back))
      :init
      (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))

#+END_SRC

** Multiple Cursors
   I am use package of magnars [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]:

#+BEGIN_SRC emacs-lisp  :tangle  ~/init.el

  (defun my-mark-all ()
      "If enable `multiple-cursors', then mark all like this, other mark buffer."
      (interactive)
      (if multiple-cursors-mode
          (mc/mark-all-words-like-this)
          (mark-whole-buffer)))


  (defun my-bob-or-mc-align ()
      "If enable `multiple-cursors', then mark then align by regexp, other bob.
  BOB - is `beginning-of-buffer'"
      (interactive)
      (if multiple-cursors-mode
          (call-interactively 'mc/vertical-align)
          (beginning-of-buffer)))


  (defun my-eob-or-mc-align-with-space ()
      "If enable `multiple-cursors', then align by spaces, other bob.
  EOB - is `end-of-buffer'"
      (interactive)
      (if multiple-cursors-mode
          (mc/vertical-align-with-space)
          (end-of-buffer)))


  (defun my-mc-mark-like-this-or-edit-lines ()
      "If region on some lines, `mc/edit-lines' other `mc/mark-next-like-this'."
      (interactive)
      (if (and (region-active-p)
               (not (eq (line-number-at-pos (region-beginning))
                        (line-number-at-pos (region-end)))))
          (call-interactively 'mc/edit-lines)
          (call-interactively 'mc/mark-next-like-this-word)))

  (use-package multiple-cursors :ensure t)

  (use-package multiple-cursors
      :config
      (add-to-list 'mc--default-cmds-to-run-once 'my-mark-all)
      (add-to-list 'mc--default-cmds-to-run-once
                   'my-mc-mark-like-this-or-edit-lines)
      (add-to-list 'mc--default-cmds-to-run-once
                   'my-bob-or-mc-align)
      (add-to-list 'mc--default-cmds-to-run-once
                   'my-eob-or-align-with-spaces)
      (add-to-list 'mc--default-cmds-to-run-once
                   'my-mc-mark-like-this-or-edit-lines)
      :bind
      (:map xah-fly-command-map
            ("7"         . my-mc-mark-like-this-or-edit-lines)
            ("SPC 7"     . mc/mark-previous-like-this-word)
            ("SPC TAB 7" . mc/reverse-regions)
            ("SPC d 7"   . mc/unmark-next-like-this)
            ("SPC h"     . my-bob-or-mc-align)
            ("SPC n"     . my-eob-or-mc-align-with-space)
            ("SPC a"     . my-mark-all)))

#+END_SRC

** Very Fast Jump
   I am use [[https://github.com/abo-abo/avy][avy]]:
   
#+BEGIN_SRC emacs-lisp  :tangle  ~/init.el

  (use-package avy
      :ensure t
      :custom (avy-background t)
      (avy-translate-char-function #'translate-char-from-russian)
      :bind ((:map xah-fly-command-map)
             ("n"           . avy-goto-char)
             ("SPC SPC v"   . avy-yank-word)
             ("SPC SPC x"   . avy-teleport-word)
             ("SPC SPC t"   . avy-mark-word)
             ("SPC SPC 5"   . avy-zap)
             ("SPC SPC c"   . avy-copy-word)
             ("SPC SPC d"   . avy-kill-word-stay)
             ("SPC SPC TAB" . avy-transpose-words)
             ("SPC SPC -"   . avy-sp-splice-sexp-in-word)
             ("SPC SPC 8"   . avy-kill-word-move)
             ("SPC SPC o"   . avy-change-word)
             ("SPC SPC 9"   . avy-sp-change-enclosing-in-word)
             ("SPC SPC z"   . avy-comment-line)
             ("SPC SPC 5"   . avy-zap)
             ("SPC SPC a v" . avy-copy-region)
             ("SPC SPC a d" . avy-kill-region)
             ("SPC SPC a x" . avy-move-region)
             ("SPC SPC a c" . avy-kill-ring-save-region)
             ("SPC SPC l v" . avy-copy-line)
             ("SPC SPC l ;" . avy-goto-end-of-line)
             ("SPC SPC l x" . avy-move-line)
             ("SPC SPC l c" . avy-kill-ring-save-whole-line)
             ("SPC SPC l d" . avy-kill-whole-line)))


  (defun translate-char-from-russian (russian-char)
      "Translate RUSSIAN-CHAR to corresponding char on qwerty keyboard.
  I am use йцукенг russian keyboard."
      (cl-case russian-char
        (?й ?q)
        (?ц ?w)
        (?у ?e)
        (?к ?r)
        (?е ?t)
        (?н ?y)
        (?г ?u)
        (?ш ?i)
        (?щ ?o)
        (?з ?p)
        (?ф ?a)
        (?ы ?s)
        (?в ?d)
        (?а ?f)
        (?п ?g)
        (?р ?h)
        (?о ?j)
        (?л ?k)
        (?д ?l)
        (?я ?z)
        (?ч ?x)
        (?с ?c)
        (?м ?v)
        (?и ?b)
        (?т ?n)
        (?ь ?m)
        (t russian-char)))

  (defun avy-goto-word-1-with-action (char action &optional arg beg end symbol)
      "Jump to the currently visible CHAR at a word start.
  The window scope is determined by `avy-all-windows'.
  When ARG is non-nil, do the opposite of `avy-all-windows'.
  BEG and END narrow the scope where candidates are searched.
  When SYMBOL is non-nil, jump to symbol start instead of word start.
  Do action of `avy' ACTION.'"
      (interactive (list (read-char "char: " t)
                         current-prefix-arg))
      (avy-with avy-goto-word-1
          (let* ((str (string char))
                 (regex (cond ((string= str ".")
                               "\\.")
                              ((and avy-word-punc-regexp
                                    (string-match avy-word-punc-regexp str))
                               (regexp-quote str))
                              ((<= char 26)
                               str)
                              (t
                               (concat
                                (if symbol "\\_<" "\\b")
                                str)))))
              (avy-jump regex
                        :window-flip arg
                        :beg beg
                        :end end
                        :action action))))

  (defun avy-zap (char &optional arg)
      "Zapping to next CHAR navigated by `avy'."
      (interactive "cchar:\nP")
      (avy-jump (s-concat (char-to-string char))
                :window-flip arg
                :beg (point-min)
                :end (point-max)
                :action 'avy-action-zap-to-char))


  (defun avy-teleport-word (char &optional arg)
      "Teleport word searched by `arg' with CHAR.
  Pass ARG to `avy-jump'."
      (interactive "cchar:\nP")
      (avy-goto-word-1-with-action char 'avy-action-teleport))

  (defun avy-mark-word (char)
      "Mark word begining with CHAR searched by `avy'."
      (interactive "cchar: ")
      (avy-goto-word-1-with-action char 'avy-action-mark))


  (defun avy-copy-word (char &optional arg)
      "Copy word searched by `arg' with CHAR.
  Pass ARG to `avy-jump'."
      (interactive "cchar:\nP")
      (avy-goto-word-1-with-action char 'avy-action-copy))


  (defun avy-yank-word (char &optional arg)
      "Paste word searched by `arg' with CHAR.
  Pass ARG to `avy-jump'."
      (interactive "cchar:\nP")
      (avy-goto-word-1-with-action char 'avy-action-yank))


  (defun avy-kill-word-stay (char &optional arg)
      "Paste word searched by `arg' with CHAR.
  Pass ARG to `avy-jump'."
      (interactive "cchar:\nP")
      (avy-goto-word-1-with-action char 'avy-action-kill-stay))


  (defun avy-kill-word-move (char &optional arg)
      "Paste word searched by `arg' with CHAR.
  Pass ARG to `avy-jump'."
      (interactive "cchar:\nP")
      (avy-goto-word-1-with-action char 'avy-action-kill-move))

  (defun avy-goto-line-1-with-action (action)
      "Goto line via `avy' with CHAR and do ACTION."
      (interactive)
      (avy-jump "^." :action action))

  (defun avy-comment-line ()
      "With `avy' move to line and comment its."
      (interactive)
      (avy-goto-line-1-with-action 'avy-action-comment))

  (defun avy-action-comment (pt)
      "Saving excursion comment line at point PT."
      (save-excursion
          (goto-char pt)
          (comment-line 1)))

  (defun avy-sp-change-enclosing-in-word (ch)
      "With `avy' move to word starting with CH and `sp-change-enclosing'."
      (interactive "cchar:")
      (avy-goto-word-1-with-action ch 'avy-action-sp-change-enclosing))

  (defun avy-action-sp-change-enclosing (pt)
      "Saving excursion `sp-change-enclosing' in word at point PT."
      (save-excursion
          (goto-char pt)
          (sp-change-enclosing)))

  (defun avy-sp-splice-sexp-in-word (ch)
      "With `avy' move to word starting with CH and `sp-splice-sexp'."
      (interactive "cchar:")
      (avy-goto-word-1-with-action ch 'avy-action-sp-splice-sexp))

  (defun avy-action-sp-splice-sexp (pt)
      "Saving excursion `sp-splice-sexp' in word at point PT."
      (save-excursion
          (goto-char pt)
          (sp-splice-sexp)))

  (defun avy-change-word (ch)
      "With `avy' move to word starting with CH and change its any other."
      (interactive "cchar:")
      (avy-goto-word-1-with-action ch 'avy-action-change-word))

  (defun avy-action-change-word (pt)
      "Saving excursion navigate to word at point PT and change its."
      (save-excursion
          (avy-action-kill-move pt)
          (insert (read-string "new word, please: " (current-kill 0)))))

  (defun avy-transpose-words (char)
      "Goto CHAR via `avy' and transpose at point word to word at prev point."
      (interactive "cchar: ")
      (avy-goto-word-1-with-action char 'avy-action-transpose-words))


  (defun avy-action-transpose-words (second-pt)
      "Goto SECOND-PT via `avy' and transpose at point to word at point ago."
      (backward-sexp)
      (avy-action-yank second-pt)
      (kill-sexp)
      (goto-char second-pt)
      (yank)
      (kill-sexp))

#+END_SRC

** Smart Parens
*** Smartparens
   I am use [[https://github.com/Fuco1/smartparens/][smartparens]], for slurp expresion I am use =]=, also for splice parens I am
use =-=, for navigating I am use =.= and =m=:

#+BEGIN_SRC emacs-lisp  :tangle  ~/init.el

  (use-package smartparens
      :ensure t
      :init
      (smartparens-global-mode 1)
      :bind (("RET"       . sp-newline)
             :map
             xah-fly-command-map
             (("]"         . sp-forward-slurp-sexp)
              ("M-("       . sp-wrap-round)
              ("M-["       . sp-wrap-square)
              ("M-{"       . sp-wrap-curly)
              ("["         . sp-backward-slurp-sexp)
              ("-"         . sp-splice-sexp)
              ("SPC -"     . sp-rewrap-sexp)
              ("m"         . sp-backward-sexp)
              ("."         . sp-forward-sexp)
              ("SPC 1"     . sp-join-sexp)
              ("SPC SPC 1" . sp-split-sexp)
              ("SPC 9"     . sp-change-enclosing)
              ("SPC SPC g" . sp-kill-hybrid-sexp)
              ("SPC ="     . sp-raise-sexp)
              ("M-("       . sp-wrap-round)
              ("M-{"       . sp-wrap-curly))))

#+END_SRC
*** Special Configuration for Major Modes
    For enable builtin smartparens configuration for major modes, add require statement to =.emacs.el=, with name of major mode and smartparens prefix:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (require 'smartparens-config)

#+END_SRC

*** Delete Only Parens without Inner Contents

#+BEGIN_SRC emacs-lisp :tangle ~/init.el
(defun delete-only-1-char ()
    "Delete only 1 character before point."
    (interactive)
    (backward-char)
    (delete-char 1)
    )

(define-key xah-fly-command-map (kbd "DEL") 'delete-only-1-char)
#+END_SRC

** Smart Select Text
   I am use cool package [[https://github.com/magnars/expand-region.el/][expand-region]]:
#+BEGIN_SRC emacs-lisp  :tangle  ~/init.el
  (defun mark-inner-or-expand-region ()
      "If text is selected, expand region, otherwise then mark inner of brackets."
      (interactive)
      (if (use-region-p)
          (call-interactively 'er/expand-region)
          (progn
              (-when-let (ok (sp-get-sexp))
                  (sp-get ok
                      (set-mark :beg-in)
                      (goto-char :end-in))))))

  (use-package expand-region
      :ensure t
      :bind
      (:map xah-fly-command-map
            ("1" . er/expand-region)
            ("9" . mark-inner-or-expand-region)
            ("m" . sp-backward-up-sexp)))

#+END_SRC
** Macros
   I am use =\= in command mode for start of record macro.
   I am also use =SPC RET= for execute last macro or execute macro to lines:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el
  (defun kmacro-start-or-end-macro ()
      "If macro record have just started, then stop this record, otherwise start."
      (interactive)
      (if defining-kbd-macro
          (kmacro-end-macro 1)
          (kmacro-start-macro 1)))

  (define-key xah-fly-command-map (kbd "\\") 'kmacro-start-or-end-macro)

  (defun kmacro-call-macro-or-apply-to-lines (arg &optional top bottom)
   "If selected region, then apply macro to selected lines, otherwise call macro."
      (interactive
       (list
        1
        (if (use-region-p) (region-beginning) nil)
        (if (use-region-p) (region-end) nil)))

      (if (use-region-p)
          (apply-macro-to-region-lines top bottom)
          (kmacro-call-macro arg)))

  (define-key xah-fly-command-map (kbd "SPC RET") 'kmacro-call-macro-or-apply-to-lines)

#+END_SRC

#+RESULTS:
: kmacro-call-macro-or-apply-to-lines
** Special Strings as Seperated Buffers
   I am use [[https://github.com/magnars/string-edit.el][string-edit]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package string-edit
      :ensure t
      :bind (:map xah-fly-command-map
                  ("SPC `" . string-edit-at-point)))

#+END_SRC

** Transpose
   I am press =n=, when select text for transpose lines in region:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el


  (bind-keys :map
             xah-fly-command-map
             ("SPC TAB o" . transpose-words)
             ("SPC TAB u" . backward-transpose-words)

             ("SPC TAB l" . transpose-chars)
             ("SPC TAB j" . backward-transpose-chars)

             ("SPC TAB i" . backward-transpose-lines)
             ("SPC TAB k" . transpose-lines)

             ("SPC TAB ." . transpose-sexps)
             ("SPC TAB m" . backward-transpose-sexps)

             ("SPC TAB n" . avy-transpose-lines-bacin-region)
             ("SPC TAB t" . transpose-regions))


  (defun backward-transpose-words ()
      "As `transpose-words' but set position to backward of transpose."
      (interactive)
      (transpose-words -1))


  (defun backward-transpose-chars ()
      "As `transpose-chars' but set position to backward of transpose."
      (interactive)
      (transpose-chars -1))


  (defun backward-transpose-lines ()
      "As `transpose-lines' but set position to backward of transpose."
      (interactive)
      (transpose-lines -1))


  (defun backward-transpose-sexps ()
      "As `transpose-sexps' but set position to backward of transpose."
      (interactive)
      (transpose-sexps -1))

#+END_SRC

** Custom Deleting Text
   I am delete this line and edit this by press =w=:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defun delete-and-edit-current-line ()
      "Delete current line and instroduce to insert mode."
      (interactive)
      (beginning-of-line-text)
      (kill-line)
      (xah-fly-insert-mode-init)
      )

  (define-key xah-fly-command-map (kbd "w") 'delete-and-edit-current-line)

#+END_SRC

    I am delete content of this line (including whitespaces) on press =SPC w=:
    
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defun clear-current-line ()
      "Clear content of current line (including whitespaces)."
      (interactive)
      (kill-region (line-beginning-position) (line-end-position))
      )

  (define-key xah-fly-command-map (kbd "SPC w") 'clear-current-line)
#+END_SRC

** Custom Selecting Text
   I am press 2 times =8= for selecting 2 words

#+BEGIN_SRC emacs-lisp :tangle ~/init.el
  (defun select-current-or-next-word ()
      "If word was selected, then move to next word, otherwise select word."
      (interactive)
      (if (use-region-p)
          (forward-word)
          (xah-extend-selection))
      )

  (define-key xah-fly-command-map (kbd "8") 'select-current-or-next-word)

#+END_SRC

    I am press =g=, for deleting current block, but if selected region, then I am cancel 
this select:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defun delete-current-text-block-or-cancel-selection ()
      "If text is selected, then cancel selection, otherwise delete current block."
      (interactive)
      (if (use-region-p)
          (deactivate-mark)
          (xah-delete-current-text-block)))

  (define-key xah-fly-command-map (kbd "g") nil)
  (define-key xah-fly-command-map (kbd "g") 'delete-current-text-block-or-cancel-selection)

#+END_SRC

I am press =-= for change position when select text to begin/end of selected region:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (define-key-when xah-fly-command-map "-" 'exchange-point-and-mark 'use-region-p)

#+END_SRC

** Custom Editing Text
   I am use =s= for inserting new line:
   
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defun open-line-saving-indent ()
      "Inserting new line, saving position and inserting new line."
      (interactive)
      (newline)
      (unless (s-blank-p (s-trim (thing-at-point 'line t)))
          (indent-according-to-mode))
      (forward-line -1)
      (end-of-line)
      (delete-horizontal-space t))

  (define-key xah-fly-command-map (kbd "s") 'open-line-saving-indent)

#+END_SRC

And =SPC s= for new line below and =SPC SPC s= for new line above:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defun open-line-below ()
      (interactive)
      (end-of-line)
      (newline)
      (indent-for-tab-command))

  (defun open-line-above ()
      (interactive)
      (beginning-of-line)
      (newline)
      (forward-line -1)
      (indent-for-tab-command))

  (defun new-line-in-between ()
      (interactive)
      (newline)
      (save-excursion
          (newline)
          (indent-for-tab-command))
      (indent-for-tab-command))

  (defun duplicate-current-line-or-region (arg)
    "Duplicates the current line or region ARG times.
  If there's no region, the current line will be duplicated."
    (interactive "p")
    (if (region-active-p)
        (let ((beg (region-beginning))
              (end (region-end)))
          (duplicate-region arg beg end)
          (one-shot-keybinding "d" (λ (duplicate-region 1 beg end))))
      (duplicate-current-line arg)
      (one-shot-keybinding "d" 'duplicate-current-line)))

  (defun one-shot-keybinding (key command)
    (set-temporary-overlay-map
     (let ((map (make-sparse-keymap)))
       (define-key map (kbd key) command)
       map) t))

  (defun replace-region-by (fn)
    (let* ((beg (region-beginning))
           (end (region-end))
           (contents (buffer-substring beg end)))
      (delete-region beg end)
      (insert (funcall fn contents))))

  (defun duplicate-region (&optional num start end)
    "Duplicates the region bounded by START and END NUM times.
  If no START and END is provided, the current region-beginning and
  region-end is used."
    (interactive "p")
    (save-excursion
      (let* ((start (or start (region-beginning)))
             (end (or end (region-end)))
             (region (buffer-substring start end)))
        (goto-char end)
        (dotimes (i num)
          (insert region)))))

  (defun paredit-duplicate-current-line ()
    (back-to-indentation)
    (let (kill-ring kill-ring-yank-pointer)
      (paredit-kill)
      (yank)
      (newline-and-indent)
      (yank)))

  (defun duplicate-current-line (&optional num)
    "Duplicate the current line NUM times."
    (interactive "p")
    (if (bound-and-true-p paredit-mode)
        (paredit-duplicate-current-line)
      (save-excursion
        (when (eq (point-at-eol) (point-max))
          (goto-char (point-max))
          (newline)
          (forward-char -1))
        (duplicate-region num (point-at-bol) (1+ (point-at-eol))))))

  (defvar yank-indent-modes '(prog-mode
                              sgml-mode
                              js2-mode)
    "Modes in which to indent regions that are yanked (or yank-popped)")

  (defvar yank-advised-indent-threshold 1000
    "Threshold (# chars) over which indentation does not automatically occur.")

  (defun yank-advised-indent-function (beg end)
      "Do indentation, as long as the region isn't too large."
      (if (<= (- end beg) yank-advised-indent-threshold)
          (indent-region beg end nil)))

  (defadvice yank (after yank-indent activate)
      "If current mode is one of 'yank-indent-modes, indent yanked text.
  With prefix arg don't indent."
      (if (and (not (ad-get-arg 0))
               (--any? (derived-mode-p it) yank-indent-modes))
          (let ((transient-mark-mode nil))
              (yank-advised-indent-function (region-beginning) (region-end)))))

  (defadvice yank-pop (after yank-pop-indent activate)
      "If current mode is one of 'yank-indent-modes, indent yanked text.
  With prefix arg don't indent."
      (if (and (not (ad-get-arg 0))
               (member major-mode yank-indent-modes))
          (let ((transient-mark-mode nil))
              (yank-advised-indent-function (region-beginning) (region-end)))))

  (defun yank-unindented ()
      (interactive)
      (yank 1))

  (defun kill-to-beginning-of-line ()
      (interactive)
      (kill-region (save-excursion (beginning-of-line) (point))
                   (point)))

  (bind-keys :map
             xah-fly-command-map
             ("SPC y"     . duplicate-current-line-or-region)
             ("SPC s"     . open-line-below)
             ("SPC e"     . kill-to-beginning-of-line)
             ("SPC k RET" . new-line-in-between)
             ("SPC SPC s" . open-line-above))

#+END_SRC

#+RESULTS:
: open-line-above


And I am press =p= for inserting space, and if I am selected region,  for inserting space
to beginning of each line:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defun insert-space-before-line ()
      "Saving position, insert space to beginning of current line."
       (interactive)
       (save-excursion (beginning-of-line-text)
                      (xah-insert-space-before))
      )

  (defun insert-spaces-before-each-line-by-line-nums (start-line end-line)
      "Insert space before each line in region (`START-LINE`; `END-LINE`)."
      (unless (= 0 (+ 1 (- end-line start-line)))
          (goto-line start-line)
          (insert-space-before-line)
          (insert-spaces-before-each-line-by-line-nums (+ start-line 1) end-line))
      )

  (defun insert-spaces-before-each-line (beg end)
      "Insert spaces before each selected line, selected line indentifier with `BEG` & `END`."
      (interactive "r")
      (save-excursion
          (let (deactivate-mark)
              (let ((begining-line-num (line-number-at-pos beg))
                    (end-line-num (line-number-at-pos end)))
                  (insert-spaces-before-each-line-by-line-nums begining-line-num end-line-num))))
      )

  (defun insert-spaces-before-or-to-beginning-of-each-line (beg end)
      "Insert space, and if selected region, insert space to beginning of each line, text is should will indentifier with `BEG` & `END`."
      (interactive (list (if (use-region-p) (region-beginning))
                         (if (use-region-p) (region-end))))
      (if (use-region-p)
          (insert-spaces-before-each-line beg end)
          (xah-insert-space-before))
      )


  (define-key xah-fly-command-map (kbd "p") nil)
  (define-key xah-fly-command-map (kbd "p") 'insert-spaces-before-or-to-beginning-of-each-line)

#+END_SRC

** Custom Navigation
   I am press =m= and =.= for go to next, previous sexp:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (define-key xah-fly-command-map (kbd "m") 'backward-sexp)
  (define-key xah-fly-command-map (kbd ".") 'forward-sexp)

#+END_SRC

** Rectangles

I am press =SPC t= for enable =rectangle-mark-mode=, and =f= when =rectangle-mark-mode=
is enabled for replace rectangle:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el
  (require 'rect)

  (define-key xah-fly-command-map (kbd "SPC t") 'rectangle-mark-mode)
  (define-key xah-fly-command-map (kbd "SPC v") 'yank-rectangle)

  (define-key-when xah-fly-command-map "c" 'copy-rectangle-as-kill
           (lambda () rectangle-mark-mode))

  (define-key-when xah-fly-command-map "d" 'kill-rectangle
           (lambda () rectangle-mark-mode))

  (define-key-when xah-fly-command-map "x" 'kill-rectangle
           (lambda () rectangle-mark-mode))

  (define-key-when xah-fly-command-map "f" 'replace-rectangle
           (lambda () rectangle-mark-mode))

  (define-key-when xah-fly-command-map "s" 'open-rectangle
          (lambda () rectangle-mark-mode))

  (define-key-when xah-fly-command-map "-" 'rectangle-exchange-point-and-mark
          (lambda () rectangle-mark-mode))

#+END_SRC

** Indent Settings
   
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (setq-default indent-tabs-mode nil)
  (setq-default tab-width          4)
  (setq-default c-basic-offset     4)
  (setq-default standart-indent    4)
  (setq-default lisp-body-indent   4)


  (defun select-current-line ()
      "Select as region current line."
      (interactive)
      (forward-line 0)
      (set-mark (point))
      (end-of-line)
      )


  (defun indent-line-or-region ()
      "If text selected, then indent it, otherwise indent current line."
      (interactive)
      (save-excursion
          (if (use-region-p)
              (indent-region (region-beginning) (region-end))
              (funcall indent-line-function)
              ))
      )


  (global-set-key (kbd "RET") 'newline-and-indent)
  (define-key xah-fly-command-map (kbd "q") 'indent-line-or-region)
  (define-key xah-fly-command-map (kbd "SPC q") 'join-line)

  (setq lisp-indent-function  'common-lisp-indent-function)

#+END_SRC

I am press =SPC , ,= for go to defnition:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (define-key xah-fly-command-map (kbd "SPC .") 'xref-find-definitions)

#+END_SRC

* Support of Languages
** Functions for extending functional of language
*** Functions for Navigation
    Function `add-nav-to-imports-for-language`, is define keys for go to imports:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

(defmacro add-nav-to-imports-for-language (language to-imports-function)
  "Bind `TO-IMPORTS-FUNCTION` to `LANGUAGE`-map."
      `(let ((language-hook (intern (s-append "-hook" (symbol-name ',language)))))
          (add-hook
            language-hook
            (lambda ()
                (define-key
                    xah-fly-command-map
                    (kbd "SPC SPC i")
                    ',to-imports-function)))))

#+END_SRC

*** Functions for Pretty View
  I am use [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]] for centering content of org file:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el
  (require 'face-remap)

  (use-package visual-fill-column
      :ensure t)

  (defun visual-fill (&optional width)
      (interactive)
      (or width (setq width 70))
      (setq-default visual-fill-column-width width
                    visual-fill-column-center-text t)
      (text-scale-mode 0)
      (visual-fill-column-mode 1))
#+END_SRC

*** Functions for Import
    Function `add-import-keymap-for-language` defines key for `add-import`.

#+BEGIN_SRC emacs-lisp :tangle ~/init.el
  (defmacro add-import-keymap-for-language (language add-import-function)
      "Bind `ADD-IMPORT-FUNCTION` to `LANGUAGE`-map."
      `(let ((language-hook (intern (s-append "-hook" (symbol-name ',language)))))
           (add-hook
            language-hook
            (lambda ()
                (define-key
                    xah-fly-command-map
                    (kbd "SPC i")
                    ',add-import-function)))))

#+END_SRC

** Supported Languages
*** LaTeX
    I am use [[https://github.com/emacsmirror/auctex][auctex]]:
    
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package auctex
      :ensure t)

#+END_SRC

**** Vars
     Variable `latex-documentclasses` is list of documentclasses in Emacs, each element
 of this list is name of documentclass in lower case. Defaults to:
 
 #+BEGIN_SRC emacs-lisp :tangle ~/init.el
 (setq latex-documentclasses
     '("article" "reoport" "book" "proc" "minimal" "slides" "memoir" "letter" "beamer"))
 #+END_SRC
 
**** Visual Fill

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (dolist (mode (list 'TeX-mode-hook
                      'tex-mode-hook
                      'latex-mode-hook
                      'LaTeX-mode-hook))
      (add-hook mode (lambda () (call-interactively 'visual-fill))))


#+END_SRC
**** Keymaps
#+BEGIN_SRC emacs-lisp :tangle ~/init.el
  (defun latex-wrap-text (command)
      "If regions select, wrap region with COMMAND, otherwise wrap word."
      (unless (use-region-p)
          (set-mark (point))
          (forward-word)
          (exchange-point-and-mark)
          (backward-word))
      (goto-char (region-beginning))
      (insert (s-lex-format "\\${command}{"))
      (goto-char (region-end))
      (insert "}")
      (indent-region (region-beginning) (region-end)))


  (defun latex-make-text-italic ()
      "If regions select, wrap region with `emph`, otherwise make word."
      (interactive)
      (latex-wrap-text "emph"))

  (defun latex-make-text-bold ()
      "If regions select, wrap region with `textbf`, otherwise make word."
      (interactive)
      (latex-wrap-text "emph"))

  (defun latex-make-text-formula ()
      "If regions select, make region formula, otherwise make line formula."
      (interactive)
      (unless (use-region-p)
          (end-of-line)
          (set-mark (point-at-bol)))
      (let ((text-beg (region-beginning))
            (text-end (region-end)))
          (deactivate-mark)
          (goto-char text-beg)
          (insert "\\[")
          (goto-char (+ text-end 2))
          (insert "\\]")))


  (use-package latex
      :major-mode-map (TeX-mode LaTeX-mode tex-mode latex-mode)
      :bind (:map
             my-latex-local-map
             ("m" . helm-insert-latex-math)
             ("i" . latex-make-text-italic)
             ("b" . latex-make-text-bold)
             ("f" . latex-make-text-formula)))


#+END_SRC
**** Auto Complete for LaTeX
     I am use [[https://github.com/vspinu/company-math][company-math]] and [[https://github.com/alexeyr/company-auctex][company-auctex]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package company-math
      :ensure t
      :init
      (defun my-company-math-setup ()
          "Setup for `company-math'."
          (add-to-list 'company-backends 'company-math-symbols-latex)
          (add-to-list 'company-backends 'company-latex-commands))
      (add-hook 'LaTeX-mode 'my-company-math-setup))


  (use-package company-auctex
      :ensure t
      :config
      (company-auctex-init))

#+END_SRC

*** Org
    I am consider that Org Mode builtin Emacs:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package org
      :major-mode-map (org-mode)
      :bind (:map
             my-org-local-map
             ("'"   . org-edit-special)
             ("l"   . org-insert-link)
             ("t"   . org-babel-tangle)
             ("RET" . org-open-at-point)))

#+END_SRC

**** Centering 
     I am centering text, when enable =org-mode=:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (add-hook 'org-mode-hook (lambda () (call-interactively 'visual-fill)))

#+END_SRC

**** Load from Wiki
     I am use [[https://github.com/progfolio/wikinforg][wikinforg]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package wikinforg
    :ensure t)

#+END_SRC

**** Drag and Drop Images
     I am use [[https://github.com/abo-abo/org-download][org-download]] for this:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package org-download
      :ensure t
      :hook
      (dired-mode-hook . org-download-enable)
      )

#+END_SRC

**** Navigation
     I am use [[https://github.com/emacs-helm/helm-org][helm-org]] for navigation in Org Mode:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

    (use-package helm-org
        :ensure t
        :bind (:map org-mode-map
                    ([remap helm-semantic-or-imenu]
                     . helm-org-in-buffer-headings)))

#+END_SRC

*** Elisp
**** Special Linters
***** Package Linter
      I am use [[https://github.com/purcell/package-lint][package-lint]] for lint my packages for Melpa for view I am use [[https://github.com/purcell/flycheck-package][flycheck-package]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package package-lint
      :ensure t
      )

  (use-package flycheck-package
      :ensure t
      :init
      (flycheck-package-setup)
      )

#+END_SRC

# ***** ELSA (Static Analyzer)
#       I am use [[https://github.com/emacs-elsa/Elsa#how-do-i-run-it][ELSA]] and [[https://github.com/emacs-elsa/flycheck-elsa][flycheck-elsa]]:

# #+BEGIN_SRC emacs-lisp :tangle ~/init.el

#   (use-package elsa
#       :ensure t)

#   (use-package flycheck-elsa
#       :ensure t
#       :init
#       (add-hook 'emacs-lisp-mode-hook #'flycheck-elsa-setup)
#       ;; (add-to-list 'flycheck-checkers 'flyc))
#       )

# #+END_SRC

**** Refactoring
     I am use [[https://github.com/Wilfred/emacs-refactor][emacs-refactor]] for refactor not only in =emacs-lisp=:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package emr
      :ensure t
      :bind (:map xah-fly-command-map
                  ("SPC /" . emr-show-refactor-menu)))
#+END_SRC

**** Package Manager
     I am use [[https://github.com/cask/cask/][Cask]] for manage packages of =elisp=:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package cask-mode
      :ensure t
      )

#+END_SRC

**** Elisp Format Code
     I am use [[https://github.com/riscy/elfmt][elfmt]] of =Riscky=:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el
  (use-package elfmt
      :config
      (elfmt-global-mode 1))

#+END_SRC


**** Modern Documentation
     I am use [[https://github.com/Wilfred/suggest.el][suggest]], I am just type print input and excepted output and see suggesting examples as this do:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package suggest
      :ensure t
      )

#+END_SRC

**** Elisp Docstrings Mode
     I am use [[https://github.com/Fuco1/elisp-docstring-mode][elisp-docstring-mode]] with [[https://github.com/Fuco1/elisp-docstring-mode][string-edit]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

(defun my-edit-elisp-docstring ()
    "Edit `elisp' docstring via `string-edit' and `elisp-docstring-mode'."
    (interactive)
    (string-edit-at-point)
    (elisp-docstring-mode))

(use-package elisp-docstring-mode
    :ensure t
    :bind (:map emacs-lisp-mode-map
                ([remap string-edit-at-point] . my-edit-elisp-docstring)))


#+END_SRC

*** Markdown
    I am use [[https://github.com/jrblevin/markdown-mode/][markdown-mode]] , and for its I am centering code:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package markdown-mode
      :ensure t
      :major-mode-map t
      :bind (:map
             my-markdown-mode-local-map
             ("<SPC>"     . markdown-toggle-gfm-checkbox)
             ("b"     . markdown-insert-bold)
             ("i"     . markdown-insert-italic)
             ("l"     . markdown-insert-link)
             ("p"     . markdown-live-preview-mode)
             ("'"     . markdown-edit-code-block)
             ("<RET>" . markdown-follow-thing-at-point))
      :hook (markdown-mode . visual-fill)
      :init
      (setq markdown-imenu-generic-expression
            '(("title""^\\(.*\\)[\n]=+$" 1)
              ("h2-"  "^\\(.*\\)[\n]-+$" 1)
              ("h1"   "^# \\(.*\\)$" 1)
              ("h2"   "^## \\(.*\\)$" 1)
              ("h3"   "^### \\(.*\\)$" 1)
              ("h4"   "^#### \\(.*\\)$" 1)
              ("h5"   "^##### \\(.*\\)$" 1)
              ("h6"   "^###### \\(.*\\)$" 1)
              ("fn"   "^\\[\\^\\(.*\\)\\]" 1)))

      (add-hook 'markdown-mode-hook
                (lambda ()
                    (setq-local imenu-generic-expression
                                markdown-imenu-generic-expression))))

#+END_SRC

**** Create Table of Contents in Markdown
     I am use [[https://github.com/ardumont/markdown-toc][markdown-toc]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package markdown-toc
      :ensure t
      :bind (:map
             my-markdown-mode-local-map
             ("t" . 'markdown-toc-generate-or-refresh-toc)))

#+END_SRC

*** Python
**** Vars
     Var =py/imports-regexp= is regexp of import statements in python:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (setq py/imports-regexp "import\\|from")

#+END_SRC

Var =python-shell-interpreter= is builtin Emacs var, see docs in Emacs:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (setq python-shell-interpreter "python")

#+END_SRC

**** Navigation

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defun py-nav-to-imports ()
      "Navigate to imports in Python mode."
      (interactive)
      (push-mark)
      (let ((old-pos (point)))
          (goto-char (point-min))
          (search-forward-regexp py/imports-regexp old-pos old-pos))
      )

  (add-nav-to-imports-for-language
   python-mode
   py-nav-to-imports)

#+END_SRC

**** Linters
     
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (setq flycheck-python-flake8-command "python -m flake8")
  (setq flycheck-python-mypy-executable "python -m mypy")
  (setq flycheck-python-pylint-executable "python -m pylint")

#+END_SRC

**** Helping info
     I am use [[https://www.emacswiki.org/emacs/pydoc-info.el][pydoc-info]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package pydoc
      :ensure t)

#+END_SRC

**** Autocomplete
     I am hasn't autocompletion special for python, so I enable default =dabbrev-autocompletion=:
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defun enable-dabbrev-company-backend ()
      "Add `company-dabbrev' backend to `company-backends' for local major mode."
      (interactive)
      (setq-local company-backends (cons 'company-dabbrev company-backends))
      )


  (add-hook 'python-mode-hook 'enable-dabbrev-company-backend)

#+END_SRC

*** Rust
**** Auto Completion
    I am use [[https://github.com/racer-rust/emacs-racer][racer]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package racer
      :ensure t
      :hook ((rust-mode  . racer-mode)
             (racer-mode . eldoc-mode)))

#+END_SRC
**** Check Errors
     I am use [[https://github.com/flycheck/flycheck-rust][flycheck-rust]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package flycheck-rust
      :ensure t
      :config
      (flycheck-rust-setup))

#+END_SRC

*** Go Lang
    I am use [[https://github.com/dominikh/go-mode.el][go-mode]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package go-mode
      :ensure t)

  (use-package go-eldoc
      :ensure t
      :hook (go-mode-hook . 'go-eldoc-setup))

#+END_SRC

**** Add Import

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (add-import-keymap-for-language go-mode
                                  go-import-add)

#+END_SRC

*** PDF
    I am use [[https://github.com/vedang/pdf-tools][pdf-tools]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package pdf-tools
      :ensure t
      )

#+END_SRC

*** Haskell
    I am use [[https://github.com/haskell/haskell-mode][haskell-mode]], and I love =indention-mode=:

 #+BEGIN_SRC emacs-lisp :tangle ~/init.el

   (use-package haskell-mode
       :ensure t
       :hook (haskell-mode . haskell-indent-mode))

   (add-import-keymap-for-language
    haskell-mode
    haskell-add-import)

   (add-nav-to-imports-for-language
    haskell-mode
    haskell-navigate-imports)

 #+END_SRC
**** Auto Completion for Haskell
     I am use [[https://github.com/horellana/company-ghci][company-ghci]]:
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package company-ghci
      :ensure t
      :init
      (push 'company-ghci company-backends)
      (add-hook 'haskell-mode-hook 'company-mode)
      (add-hook 'haskell-interactive-mode-hook 'company-mode))

#+END_SRC
     
*** JavaScript (Node.js)
**** Variables
     Variable `js/imports-regexp` if regular expression for search imports in JS. 
Defaults to:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (setq js/imports-regexp "import")

#+END_SRC

Variable `js/function-or-class-regexp` if regular expression for search imports in JS. 
Defaults to:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (setq js/function-or-class-regexp "function \\|class ")

#+END_SRC

**** Repl
     I am use [[https://github.com/redguardtoo/js-comint][js-comint]] for run my JS' code:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package js-comint
      :ensure t)

  (if (user-os-windows-p)
      (setq js-comint-program-command "C:/Program Files/nodejs/node.exe"))

#+END_SRC

**** Linters
     I am use some packages which you can see on [[http://codewinds.com/blog/2015-04-02-emacs-flycheck-eslint-jsx.html#summary][this]] page:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package web-mode
      :ensure t)

  (defun my-enable-flycheck ()
      (flycheck-mode 1))

  (use-package js2-mode
      :ensure t
      :mode "\\.js$"
      :custom
      (js2-allow-rhino-new-expr-initializer nil)
      (js2-auto-indent-p nil)
      (js2-enter-indents-newline nil)
      (js2-global-externs '("module"
                            "require"
                            "buster"
                            "sinon"
                            "assert"
                            "refute"
                            "setTimeout"
                            "clearTimeout"
                            "setInterval"
                            "clearInterval"
                            "location"
                            "__dirname"
                            "console"
                            "JSON"))
      (js2-idle-timer-delay 0.1)
      (js2-indent-on-enter-key nil)
      (js2-mirror-mode nil)
      (js2-strict-inconsistent-return-warning nil)
      (js2-auto-indent-p t)
      (js2-include-rhino-externs nil)
      (js2-include-gears-externs nil)
      (js2-concat-multiline-strings 'eol)
      (js2-rebind-eol-bol-keys nil)
      (js2-show-parse-errors nil)
      (js2-strict-missing-semi-warning nil)
      (js2-strict-trailing-comma-warning t)
      :hook (js2-mode . my-enable-flycheck))

#+END_SRC

**** Navigation

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defun js/nav-to-imports ()
      "Navigate to imports in JS mode."
      (interactive)
      (push-mark)
      (let ((old-pos (point)))
          (goto-char (point-min))
          (search-forward-regexp js/imports-regexp old-pos old-pos))
      )

  (add-nav-to-imports-for-language
   js2-mode
   js/nav-to-imports)


#+END_SRC

*** JSON
    I am use [[https://github.com/Sterlingg/json-snatcher][json-snatcher]] for copy JSON "path" to current node:
For this I am press =SPC l c=:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package json-mode
      :major-mode-map t)


  (use-package json-snatcher
      :ensure t
      :bind
      (:map
       my-json-mode-local-map
       ("c" . jsons-print-path)))

#+END_SRC

#+RESULTS:
: my-json-setup

*** HTML
**** Variables
     Variable =html-modes= is list of modes which is for =html=:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defcustom html-modes '(web-mode html-mode mhtml-mode)
    "List of `html` major modes.")

#+END_SRC

**** Web Mode
    I am use [[https://web-mode.org][web-mode]] and [[https://github.com/smihica/emmet-mode][emmet]] and [[https://github.com/jcs-elpa/auto-rename-tag][auto-rename-tag]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el
  (use-package web-mode
      :ensure t
      :hook (web-mode . yas-minor-mode-off)
      :custom
      (web-mode-script-padding 1)
      (web-mode-block-padding 0))
#+END_SRC

**** Auto Rename Tag
     #+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package auto-rename-tag
      :ensure t
      :config
      :init
      (--each html-modes
          (add-hook (intern (s-append "-hook" (symbol-name it)))
                    (lambda () (auto-rename-tag-mode 38)))))

     #+END_SRC

**** Emmet

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package emmet-mode
      :ensure t
      :custom (emmet-move-cursor-between-quotes t)
      :hook
      (web-mode . emmet-mode)
      (mhtml-mode . emmet-mode)
      (css-mode . emmet-mode)
      (html-mode . emmet-mode))


  (use-package helm-emmet
      :ensure t
      :init
      (defun fast-exec-helm-emmet-keys ()
          "Keymaps for `helm-emmet'."
          (fast-exec/some-commands
           ("View Emmet Cheat" 'helm-emmet)))
      (fast-exec/register-keymap-func 'fast-exec-helm-emmet-keys)
      (fast-exec/reload-functions-chain))

#+END_SRC

**** =Paredit= for HTML
     I am use [[https://github.com/magnars/tagedit][tagedit]] of =magnars=:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el
  (use-package tagedit
      :ensure t
      :init
      (--each html-modes
          (let ((map-symbol (intern (s-append "-map" (symbol-name it))))
                map)
              (when (boundp map-symbol)
                  (setq map (eval map-symbol))
                  (define-key
                      map
                      [remap sp-kill-hybrid-sexp]
                      'tagedit-kill)
                  (define-key
                      map
                      [remap sp-join-sexp]
                      'tagedit-join-tags)
                  (define-key
                      map
                      [remap sp-raise-sexp]
                      'tagedit-raise-tag)
                  (define-key
                      map
                      [remap sp-splice-sexp]
                      'tagedit-splice-tag)
                  (define-key
                      map
                      [remap sp-change-enclosing]
                      'tagedit-kill-attribute)))))

#+END_SRC

**** Auto Complete for HTML
     I am use [[https://github.com/osv/company-web][company-web]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package company-web
      :ensure t
      :init
      (add-hook 'web-mode-hook
                (lambda ()
                    (set (make-local-variable 'company-backends)
                         '(company-web-html))
                    (company-mode t))))

#+END_SRC

*** CSS
    I am use =web-mode= and builtin =css-mode=:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package css-mode)

#+END_SRC

**** Fly Documentation
    I am use =css-eldoc= from =Elpa=:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package css-eldoc
      :ensure t
      :init
      (dolist (hook (list 'web-mode-hook 'css-mode-hook))
          (add-hook hook 'css-eldoc-enable)))

#+END_SRC
* Support of Some Special Modes
** Calc
   I am use built-in emacs =calc=, I disable =xah-fly-keys= when run calc:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (add-hook 'calc-mode-hook (lambda () (interactive) (xah-fly-keys 0)))
  (add-hook 'calc-end-hook (lambda () (interactive) (xah-fly-keys 38)))

#+END_SRC

* Small Organize Tricks
** Very Small Tricks

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (show-paren-mode 2)
  (setq make-backup-files         nil)
  (setq auto-save-list-file-name  nil)
  (defalias 'yes-or-no-p 'y-or-n-p)
  (toggle-truncate-lines 38)

#+END_SRC
** Highlight Git Changes
   I am use [[https://github.com/emacsorphanage/git-gutter][git-gutter]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package git-gutter
      :ensure t
      :hook
      (prog-mode . git-gutter-mode))

#+END_SRC
** See Emacs [Lisp] Errors, Messages
   I am use [[https://github.com/akirak/helm-tail][helm-tail]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package helm-tail
      :ensure t
      :init
      (defun fast-exec-define-helm-tail-keys ()
          "This is bind `fast-exec' with `helm-tail'."
          (fast-exec/some-commands
           ("Open Tail" 'helm-tail)))
      (fast-exec/register-keymap-func 'fast-exec-define-helm-tail-keys)
      (fast-exec/reload-functions-chain))

#+END_SRC

** Helpful
*** Which Key?
    
    I am use [[https://github.com/justbur/emacs-which-key][which-key]]:
    
#+BEGIN_SRC emacs-lisp  :tangle  ~/init.el
(use-package which-key
    :ensure t
    :config
    (which-key-setup-side-window-bottom)
    (which-key-mode))
#+END_SRC
*** Helpful Package
    I am use [[https://github.com/Wilfred/helpful][helpful]], for pretty help info about lisp functions and major modes:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package helpful
      :ensure t
      :init
      (global-set-key (kbd "C-h f") #'helpful-callable)
      (global-set-key (kbd "C-h v") #'helpful-variable)
      (global-set-key (kbd "C-h k") #'helpful-key)
      (global-set-key (kbd "C-c C-d") #'helpful-at-point)
      (global-set-key (kbd "C-h F") #'helpful-function)
      (global-set-key (kbd "C-h C") #'helpful-command))

#+END_SRC

** Framework for Incremental Completions and Narrowing Selections 
   I am use [[https://github.com/emacs-helm/helm][HELM]]:
   
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package helm
      :ensure t
      :custom (helm-M-x-fuzzy-match t)
      :init (helm-autoresize-mode 1) (helm-mode 1)
      :bind (:map
             xah-fly-command-map
             ("SPC SPC f" . helm-find-files)))


#+END_SRC

** Translate
   I am use [[https://github.com/atykhonov/google-translate][google-translate]]:
   
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package google-translate
      :ensure t
      :bind
      (:map xah-fly-command-map
            ("SPC \\" . google-translate-at-point)))

  (defun google-translate--search-tkk ()
    "Search TKK. From https://github.com/atykhonov/google-translate/issues/137.
  Thank you https://github.com/leuven65!"
    (list 430675 2721866130))

#+END_SRC

** Command Log
   I am use [[https://github.com/lewang/command-log-mode][command-log-mode]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package command-log-mode
      :ensure t)

#+END_SRC

** Whitespaces Mode
   I am enable whitespaces mode on =prog-mode=:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (add-hook 'prog-mode-hook 'whitespace-mode)

#+END_SRC

** Visual Fill Line Mode
   I am ussally use =visual-fill-line-mode=:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (add-hook 'change-major-mode-hook 'visual-line-mode)

#+END_SRC

** Auto Fill Paragraphs
   I am enable [[https://github.com/davidshepherd7/aggressive-fill-paragraph-mode/][aggressive-fill-paragraph-mode]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package aggressive-fill-paragraph
      :ensure t
      :config
      (afp-setup-recommended-hooks))

#+END_SRC

** Scratches
   I am press =C-t= for opening scratch for this I am use [[https://github.com/ieure/scratch-el][scratch-el]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package scratch
      :ensure t
      :bind (("C-t" . scratch))
      )

#+END_SRC

** Sub Word Mode
   I am use builtin =subword-mode=:
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (global-subword-mode)

#+END_SRC

** Syntax Subword Mode
   I am use [[https://melpa.org/#/syntax-subword][syntax-subword]], for example if I am in current situation:

#+BEGIN_SRC shell
   \|print(name)
#+END_SRC

   And i am need to delete indent, I am just delete its when delete backward word:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package syntax-subword
      :ensure t
      :custom
      (syntax-subword-skip-spaces t)
      :config
      (global-syntax-subword-mode)
      )

#+END_SRC

** Cow Say
   I am use [[https://github.com/lassik/emacs-cowsay][very serious cowsay]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package cowsay
      :ensure t
      :custom
      (cowsay-directories '("~/.emacs.d/cows"))
      :config
      (defun fast-exec-define-cowsay-keymaps ()
          "Some useful keymaps for `cowsay'/`fast-exec'."
          (fast-exec/some-commands
           ("Cow Say String..."  'cowsay-string)
           ("Cow Say Region..."  'cowsay-region)
           ("Cow Say and Insert" 'cowsay-replace-region)
           ("Cow Say Load Cows"  'cowsay-load-cows)))
      (fast-exec/register-keymap-func 'fast-exec-define-cowsay-keymaps)
      (fast-exec/reload-functions-chain))

#+END_SRC

** Auto Save
   I am use [[https://github.com/bbatsov/super-save][super-save]]:
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (add-to-list 'load-path "~/projects/super-save/")

  (use-package super-save
      :config
      (setq super-save-exclude '("Emacs.org"))
      (setq auto-save-default nil)
      (super-save-mode 38))

#+END_SRC

** Read Documentation for Developers
   I am use [[https://github.com/astoff/devdocs.el][devdocs]] for see documentation from [[https://devdocs.io][DevDocs]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package devdocs
      :ensure t
      :hook (python-mode . (lambda ()
                                (setq-local devdocs-current-docs
                                            '("python~3.9"))))
      )

#+END_SRC

** Pomidor
   For pomidor I am use [[https://github.com/TatriX/pomidor][pomidor]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package pomidor
      :ensure t
      :bind (("<f12>" . pomidor))
      :custom
      (pomidor-sound-tick . nil)
      (pomidor-sound-tack . nil)
      :hook
      (pomidor-mode . (lambda ()
                          (display-line-numbers-mode -1)
                          (setq left-fringe-width 0 right-fringe-width 0)
                          (setq left-margin-width 2 right-margin-width 0)
                          (set-window-buffer nil (current-buffer)))))

#+END_SRC

** Pacman
   I am use [[https://github.com/semenInRussia?tab=stars][pacmacs]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package pacmacs
      :ensure t
      :init
      (defun fast-exec-define-pacmacs-keys ()
          "Bind `fast-exec' and `pacmacs'."
          (fast-exec/some-commands
           ("Play to Pacmacs" 'pacmacs-start))
          )
      (fast-exec/register-keymap-func 'fast-exec-define-pacmacs-keys)
      (fast-exec/reload-functions-chain))

#+END_SRC

** Wikipedia
   I am use [[https://github.com/emacs-helm/helm-wikipedia][helm-wikipedia]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package helm-wikipedia
      :ensure t)

#+END_SRC


#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package helm-spotify-plus
      :ensure t)

#+END_SRC

** View Github Stars
   I am use [[https://github.com/Sliim/helm-github-stars][helm-github-stars]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package helm-github-stars
      :ensure t
      :custom
      (helm-github-stars-username "semeninrussia")
      :init
      (defun fast-exec-define-helm-github-stars ()
          "Bind `helm-github-stars' and `fast-exec'."
          (fast-exec/some-commands
           ("View Github Stars" 'helm-github-stars-fetch)))
      (fast-exec/register-keymap-func 'fast-exec-define-helm-github-stars)
      (fast-exec/reload-functions-chain))

#+END_SRC

** Easy Generate .gitignore
   I am use [[https://github.com/jupl/helm-gitignore][helm-gitignore]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  ;; (use-package helm-gitignore
  ;;     :ensure t
  ;;     :init
  ;;     (defun fast-exec-define-helm-gitignore-keys ()
  ;;         "Bind `fast-exec' and `helm-gitignore'."
  ;;         (fast-exec/some-commands
  ;;          ("Generate Gitignore" 'helm-gitignore)))
  ;;     (fast-exec/register-keymap-func 'fast-exec-define-helm-gitignore-keys)
  ;;     (fast-exec/reload-functions-chain)))

#+END_SRC

** Google
   I am use [[https://github.com/cwhatley/helm-google][helm-google]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package helm-google
      :ensure t
      :init
      (defun fast-exec-helm-google-define-keys ()
          "Keymaps for `helm-google' and `fast-exec'."
          (fast-exec/some-commands
           ("Search in Google" 'helm-google)))
      (fast-exec/register-keymap-func 'fast-exec-helm-google-define-keys)
      (fast-exec/reload-functions-chain))

#+END_SRC

* Graphic User Interface
** Hide ALL
   This is standard stuf

#+BEGIN_SRC emacs-lisp :tangle ~/init.el
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode   -1)

  (add-to-list 'default-frame-alist '(fullscreen . maximized))
  (add-hook 'emacs-startup-hook 'toggle-frame-fullscreen)

#+END_SRC

** Color Theme
   I am use [[https://github.com/hlissner/emacs-doom-themes][doom-themes]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (require 'gruber-darker-theme)

  (use-package gruber-darker-theme
      :ensure t
      :init
      (load-theme 'gruber-darker t)
      )

#+END_SRC

** Numbers of lines
*** Vars 
    Var `dont-display-lines-mode` is list of modes,
for this modes willn't display numbers of lines. Defaults to:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (setq dont-display-lines-modes
        '(org-mode
          term-mode
          shell-mode
          treemacs-mode
          eshell-mode
          helm-mode))

#+END_SRC

*** Enable and Disable
    I am display numbers of lines in each mode, excluding modes from
`dont-display-lines-mode` list:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el
  (defun display-or-not-display-numbers-of-lines ()
      "Display numbers of lines OR don't display numbers of lines.
  If current `major-mode` need to display numbers of lines, then display
  numbers of lines, otherwise don't display."
      (interactive)
      (if (-contains? dont-display-lines-modes major-mode)
          (display-line-numbers-mode 0)
          (display-line-numbers-mode 38))
      )

  (add-hook 'prog-mode-hook 'display-or-not-display-numbers-of-lines)
#+END_SRC

** Modeline
I am use [[https://github.com/gexplorer/simple-modeline][simple-modeline]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el
  (use-package doom-modeline
      :ensure t
      :defer 0.1
      :config
      (doom-modeline-def-modeline 'main
          '(bar
            matches
            buffer-info
            word-count
            selection-info)
          '(objed-state
            persp-name
            grip
            irc
            gnus
            github
            debug
            repl
            input-method
            indent-info
            buffer-encoding
            major-mode
            process
            vcs
            checker)))


#+END_SRC

** Fonts

   
#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (set-face-attribute 'default nil :font "Consolas" :height 250)
  (set-frame-font "Consolas" nil t)

#+END_SRC

#+RESULTS:

** Highlight Current Line

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

(global-hl-line-mode 1)

#+END_SRC

** Centering

I

** View Break Page Lines
   I am use [[https://github.com/purcell/page-break-lines][page-break-lines]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package page-break-lines
      :ensure t
      :init
      (global-page-break-lines-mode 38))

#+END_SRC

* Developer Environment
** Projects Management
   I am use [[https://github.com/bbatsov/projectile][projectile]]:

#+BEGIN_SRC emacs-lisp  :tangle  ~/init.el

  (use-package projectile
      :custom
      (projectile-project-search-path '("~/projects/"))
      (projectile-completion-system 'helm)
      :init (projectile-mode 1)
      :bind
      (("S-<f5>" . projectile-test-project)
       ("<f5>"   . projectile-run-project)))

  (projectile-mode 1)

#+END_SRC
*** Projectile with Helm
    I am use offical [[https://github.com/bbatsov/helm-projectile][helm-projectile]] I am press =SPC j= and find file in current project:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package helm-projectile
      :ensure t
      :bind (:map xah-fly-command-map
                  ("SPC j" . 'helm-projectile-find-file)))

#+END_SRC

** Regexp IDE
   I am use [[https://github.com/jwiegley/regex-tool][regex-tool]] for testing regexp in Emacs

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package regex-tool
      :ensure t
      :init
      (add-hook 'regex-tool-mode-hook (lambda () (toggle-frame-maximized))))

#+END_SRC

** Git
   I am use super famous [[https://github.com/magit/magit][magit]]:

#+BEGIN_SRC emacs-lisp  :tangle  ~/init.el

  (use-package magit :ensure t)

#+END_SRC

*** Fly View Authors of Changes
    For this I am use [[https://github.com/Artawower/blamer.el][blamer]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package blamer
      :ensure t
      :defer 20
      :custom
      (blamer-idle-time 0.3)
      (blamer-min-offset 70)
      :custom-face
      (blamer-face ((t :foreground "#7a88cf"
                       :background nil
                       :height 140
                       :italic t)))
      )

#+END_SRC

*** Undo with Git
    I am use [[https://github.com/jwiegley/git-undo-el][git-undo]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package git-undo
      :init
      (defun fast-exec-define-git-undo-keymaps ()
          "Bind `git-undo' and `fast-exec'."
          (fast-exec/some-commands
           ("Undo via Git" 'git-undo)))
      (fast-exec/register-keymap-func 'fast-exec-define-git-undo-keymaps)
      (fast-exec/reload-functions-chain))

#+END_SRC

*** Git Major Modes
    As major modes of (.github, gitconfig) I am use [[https://github.com/magit/git-modes][git-modes]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package git-modes
      :ensure t)

#+END_SRC

*** Genreate .gitignore
    I am use [[https://github.com/jupl/helm-gitignore][helm-gitignore]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package helm-gitignore
      :init
      (defun fast-exec-helm-gitignore-keys ()
          "Bind of `helm-gitignore' and `fast-exec'."
          (fast-exec/some-commands
           ("Generate Gitignore" 'helm-gitignore)))
      (fast-exec/register-keymap-func 'fast-exec-helm-gitignore-keys)
      (fast-exec/reload-functions-chain))

#+END_SRC

** View Directories
   I am use =dired=:
   
#+BEGIN_SRC emacs-lisp :tangle ~/init.el
(add-hook 'dired-mode-hook (lambda () (dired-hide-details-mode 1)))
#+END_SRC

** Run Command
   I am use [[https://github.com/bard/emacs-run-command][run-command]] for run special commands for special files:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package run-command
      :ensure t
      :custom
      (run-command-completion-method 'helm)
      :bind (:map xah-fly-command-map
                  ("SPC , c" . run-command)))

#+END_SRC

*** Run Command Recipes
    I am use [[https://github.com/semenInRussia/emacs-run-command-recipes/][run-command-recipes]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package run-command-recipes
      :ensure t
      :config
      (run-command-recipes-use-all))

#+END_SRC
** Projects with Templates
   I am use [[https://github.com/chrisbarrett/skeletor.el][skeletor]] for creating new projects by temlate:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package skeletor
      :ensure t
      :custom
      (skeletor-init-with-git nil)
      (skeletor-project-directory "~/projects")
      (skeletor-completing-read-function completing-read-function))

#+END_SRC
** Snitch
   I am use [[https://github.com/tsoding/snitch][snitch]] for managing TODOs

*** Highlight TODOs
    I am use [[https://github.com/tarsius/hl-todo][hl-todo]]:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (use-package hl-todo
      :ensure t
      :config (global-hl-todo-mode))

#+END_SRC
*** Run Snitch Commands
    I am use =run-command= (see in this config) for run command:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defun run-command-recipe-snitch ()
      "Recipes of `run-command' for snitch."
      (when (f-directory-p (f-join (projectile-acquire-root)
                                               ".git"))
          (list
           (list :command-name "sntich-list"
                 :display "See List of TODOs from via Snitch"
                 :command-line "snitch list")
           (list :command-name "sntich-report"
                 :display "Report to VC TODOs of Project via Snitch"
                 :command-line "snitch list"))))

  (add-to-list 'run-command-recipes 'run-command-recipe-snitch)

#+END_SRC

* MIPT
  I am make homework of [[https://mipt.ru][MIPT]], so I make small script, which create
  new file of homework of mipt's homework:

#+BEGIN_SRC emacs-lisp :tangle ~/init.el

  (defcustom my-mipt-homwork-dir "c:/Users/hrams/Documents/mfti-solutions"
    "Path to directory of MIPT solutions."
    :type 'string)

  (defcustom my-mipt-current-class-number 8
    "My current class."
    :type 'number)

  (defcustom my-mipt-lessons-types
    '("m")
    "My current class."
    :type '(repeat string))

  (defun my-new-mipt-solution ()
      "Make .tex file for solution of mipt's homework."
      (interactive)
      (let* ((mipt-lesson
              (completing-read "Print lesson's type: "
                               my-mipt-lessons-types))
             (mipt-last-solution
              (with-temp-buffer
                  (-map 'insert (f-files my-mipt-homwork-dir))
                  (sort-lines t (point-min) (point-max))
                  (delete-non-matching-lines mipt-lesson)
                  (goto-char (point-min))
                  (f-filename (s-trim (thing-at-point 'line t)))))
             mipt-number
             last-mipt-number
             mipt-section-number
             last-mipt-class-num
             last-mipt-section-num)
          (-setq
              (_ last-mipt-class-num _ last-mipt-section-num last-mipt-number)
              (s-match
               "\\(.\\)-\\(.\\)-\\(.\\)-\\(.\\)\\.tex" mipt-last-solution))
          (setq last-mipt-number (string-to-number last-mipt-number))
          (setq mipt-number (1+ last-mipt-number))
          (setq mipt-section-number (read-number "Section, Please: "
                                                 (string-to-number
                                                  last-mipt-section-num)))
          (message "mipt-number is %s" mipt-number)
          (message "last-mipt-number is %s" last-mipt-number)
          (message "mipt-section-number is %s" mipt-section-number)
          (message "last-mipt-class-num is %s" last-mipt-class-num)
          (message "last-mipt-section-num is %s" last-mipt-section-num)
          (find-file (f-join
                      my-mipt-homwork-dir
                      (format "%s-%s-%s-%s.tex"
                              last-mipt-class-num
                              mipt-lesson
                              mipt-section-number
                              mipt-number)))))

  (defun fast-exec-define-mipt-keymaps ()
      "MIPT + `fast-exec'."
      (fast-exec/some-commands
       ("New MIPT Solution" 'my-new-mipt-solution)))

  (fast-exec/register-keymap-func 'fast-exec-define-mipt-keymaps)
  (fast-exec/reload-functions-chain)

#+END_SRC

* Auto Tangle This File

#+BEGIN_SRC emacs-lisp  :tangle  ~/init.el

  (defun if-Emacs-org-then-org-babel-tangle ()
      "If current open file is Emacs.org, then `org-babel-tangle`."
      (interactive)

      (when (s-equals? (f-filename buffer-file-name) "Emacs.org")
          (org-babel-tangle)))


  (add-hook 'after-save-hook 'if-Emacs-org-then-org-babel-tangle)

#+END_SRC

